<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>API Callback</title>
<link rel="stylesheet" href="../../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../../index.html" title="Chapter&#160;1.&#160;Lua Primer 0.0">
<link rel="up" href="../api.html" title="API">
<link rel="prev" href="api_feature.html" title="API Feature">
<link rel="next" href="api_print.html" title="API Print">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="api_feature.html"><img src="../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../api.html"><img src="../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="api_print.html"><img src="../../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="lua_primer.reference.api.api_callback"></a><a class="link" href="api_callback.html" title="API Callback">API Callback</a>
</h4></div></div></div>
<p>
          An "API Callback" is a member function of the api object which
          is exposed to lua. Primer exposes these member functions as global functions
          in lua, and it obtains the pointer to the api object using "extraspace
          dispatch". This means that, a pointer to the api object is stored
          within the lua extraspace, sometime during initialization. The callbacks
          are all adapted to fetch this pointer when they are called.
        </p>
<p>
          There are two steps to this system
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              registering the callbacks in a list as they are declared and defined
            </li>
<li class="listitem">
              an API feature which gets the list and the pointer to the API object
              and installs it all in the lua state correctly.
            </li>
</ul></div>
<h4>
<a name="lua_primer.reference.api.api_callback.h0"></a>
          <span><a name="lua_primer.reference.api.api_callback.api_feature"></a></span><a class="link" href="api_callback.html#lua_primer.reference.api.api_callback.api_feature">API
          feature</a>
        </h4>
<p>
          The API feature that does this is <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">api</span><span class="special">::</span><span class="identifier">callbacks</span></code>.
        </p>
<pre class="programlisting"><span class="identifier">API_FEATURE</span><span class="special">(</span><span class="identifier">primer</span><span class="special">::</span><span class="identifier">api</span><span class="special">::</span><span class="identifier">callbacks</span><span class="special">,</span> <span class="identifier">callbacks_</span><span class="special">);</span>

<span class="special">...</span>

<span class="identifier">my_api</span><span class="special">()</span>
 <span class="special">:</span> <span class="identifier">L_</span><span class="special">(</span><span class="identifier">luaL_newstate</span><span class="special">())</span>
 <span class="special">,</span> <span class="identifier">callbacks_</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
<span class="special">{}</span>
</pre>
<p>
          Most of the standard API features that we provide, like <code class="computeroutput"><span class="identifier">userdatas</span></code>
          and <code class="computeroutput"><span class="identifier">libraries</span></code>, don't require
          special initialization, they can simply be default initialized, i.e. left
          out of the intializer list in a ctor of the API object.
        </p>
<p>
          This is not so of the <code class="computeroutput"><span class="identifier">callbacks</span></code>
          object. It needs a pointer to the api object, <code class="computeroutput"><span class="keyword">this</span></code>.
          It remembers this pointer, so that it can later put it in the lua extraspace.
        </p>
<p>
          Another thing happens when it is initialized with <code class="computeroutput"><span class="keyword">this</span></code>:
          It looks at the type of the pointer it recieved, and fetches from that
          type the <code class="computeroutput"><span class="identifier">callbacks_array</span><span class="special">()</span></code>. This is where it obtains the list of
          functions that it should manage.
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              On initialization, the <code class="computeroutput"><span class="identifier">extraspace</span></code>
              pointer is set, and all of the callbacks are placed in the global table.
            </li>
<li class="listitem">
              When persisting or unpersisting, all of the callbacks are placed in
              the permanent objects table, with slightly adjusted names to avoid
              a collision with anything else.
            </li>
</ul></div>
<h4>
<a name="lua_primer.reference.api.api_callback.h1"></a>
          <span><a name="lua_primer.reference.api.api_callback.registration_of_callbacks"></a></span><a class="link" href="api_callback.html#lua_primer.reference.api.api_callback.registration_of_callbacks">Registration
          of callbacks</a>
        </h4>
<p>
          The actual callbacks array is assembled by the api::base itself, based
          on declarations that it sees in the api object body.
        </p>
<p>
          All callbacks are registered via a macro <code class="computeroutput"><span class="identifier">USE_API_CALLBACK</span></code>.
        </p>
<p>
          This macro takes two parameters: * a token which becomes the name of the
          function in lua * a function pointer, which is adapted using the macro
          <code class="computeroutput"><span class="identifier">PRIMER_ADAPT_EXTRASPACE</span></code>
        </p>
<p>
          Thus, this macro can be used with free functions, as well as member functions
          -- it will just fallback to <code class="computeroutput"><span class="identifier">PRIMER_ADAPT</span></code>
          in that case.
        </p>
<p>
          The macro which we saw in examples was simply <code class="computeroutput"><span class="identifier">API_CALLBACK</span></code>.
          That macro is defined as follows:
        </p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">NEW_LUA_CALLBACK</span><span class="special">(</span><span class="identifier">name</span><span class="special">,</span> <span class="identifier">help</span><span class="special">)</span>                                           <span class="special">\</span>
  <span class="identifier">USE_LUA_CALLBACK</span><span class="special">(</span><span class="identifier">name</span><span class="special">,</span> <span class="identifier">help</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">owner_type</span><span class="special">::</span><span class="identifier">intf_</span><span class="special">##</span><span class="identifier">name</span><span class="special">);</span>                      <span class="special">\</span>
  <span class="keyword">auto</span> <span class="identifier">intf_</span><span class="special">##</span><span class="identifier">name</span>
</pre>
<p>
          In this definition, <code class="computeroutput"><span class="identifier">owner_type</span></code>
          is a <code class="computeroutput"><span class="keyword">typedef</span></code> created by <code class="computeroutput"><span class="identifier">api</span><span class="special">::</span><span class="identifier">base</span></code>. The macro simply calls <code class="computeroutput"><span class="identifier">USE_API_CALLBACK</span></code> using a member function
          <code class="computeroutput"><span class="identifier">intf_</span><span class="special">##</span><span class="identifier">name</span></code>, yet to be created. Then it opens
          a definition for that member function, using <code class="computeroutput"><span class="keyword">auto</span></code>
          for trailing return specifier.
        </p>
<p>
          So, there is no magic here. <code class="computeroutput"><span class="identifier">USE_API_CALLBACK</span></code>
          is what is doing the work, and all it needs is a function pointer.
        </p>
<p>
          If you prefer the syntax, you can just declare all your callbacks "normally"
          and without macros, and then register them one-by-one using <code class="computeroutput"><span class="identifier">USE_API_CALLBACK</span></code>. (But, it creates another
          point of maintanence failure since you have to manually update this list
          when functions are added or removed. You won't get a compiler error if
          you define a new callback function and forget to register it.)
        </p>
<p>
          TODO example
        </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="api_feature.html"><img src="../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../api.html"><img src="../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="api_print.html"><img src="../../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
