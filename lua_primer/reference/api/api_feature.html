<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>API Feature</title>
<link rel="stylesheet" href="../../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../../index.html" title="Chapter&#160;1.&#160;Lua Primer 0.3">
<link rel="up" href="../api.html" title="API">
<link rel="prev" href="concepts.html" title="Concepts">
<link rel="next" href="api_library.html" title="API Library">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="concepts.html"><img src="../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../api.html"><img src="../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="api_library.html"><img src="../../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="lua_primer.reference.api.api_feature"></a><a class="link" href="api_feature.html" title="API Feature">API Feature</a>
</h4></div></div></div>
<p>
          A class which matches the "API Feature" concept represents some
          functionality that we can expose to a lua VM, together with the info needed
          to serialize it.
        </p>
<p>
          An object matching the API feature concept has the following three methods:
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">my_feature</span> <span class="special">{</span>
  <span class="keyword">void</span> <span class="identifier">on_initialize</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
  <span class="keyword">void</span> <span class="identifier">on_persist_table</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
  <span class="keyword">void</span> <span class="identifier">on_unpersist_table</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
<span class="special">};</span>
</pre>
<p>
          The <code class="computeroutput"><span class="identifier">on_initialize</span></code> method
          is called when the API is initialized.
        </p>
<p>
          The <code class="computeroutput"><span class="identifier">on_persist_table</span></code> method
          is called when we are persisting the state, and need to construct the permanent
          objects table. When called, your feature will get a <code class="computeroutput"><span class="identifier">lua_State</span>
          <span class="special">*</span></code>, and can assume that the permanent
          objects table is on top of the stack. It should register each permanent
          object, using the object as the key, and (usually) a serialization token
          as the value.
        </p>
<p>
          The <code class="computeroutput"><span class="identifier">on_unpersist_table</span></code>
          method is the same, but it does the reverse. The key should be the token,
          and the value should be the object.
        </p>
<p>
          Usually, permanent objects are just function pointers, but occasionally
          they might be something else. For instance if there is a global userdata
          of some type, it could be serialized by putting it in the permanent objects
          table, rather than providing a <code class="computeroutput"><span class="identifier">__persist</span></code>
          metamethod.
        </p>
<h5>
<a name="lua_primer.reference.api.api_feature.h0"></a>
          <span><a name="lua_primer.reference.api.api_feature.extension_serial_feature"></a></span><a class="link" href="api_feature.html#lua_primer.reference.api.api_feature.extension_serial_feature">Extension:
          Serial Feature</a>
        </h5>
<p>
          Sometimes, the private state of an API feature is important, and you want
          to have an easy way to serialize that state along with the rest of the
          lua state. In this case you can provide the following two additional methods:
        </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">on_serialize</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
<span class="keyword">void</span> <span class="identifier">on_deserialize</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
</pre>
<p>
          These two methods hook into the persistence process in a different way
          -- instead of adjusting the permanent objects table, they add a value to
          the <span class="emphasis"><em>target</em></span> table.
        </p>
<p>
          When <code class="computeroutput"><span class="identifier">on_serialize</span></code> is called,
          the feature should push one lua value onto the stack which will be associated
          to it and saved. It may be a complex table or any other thing that primer
          is able to serialize. <span class="emphasis"><em>Exactly one value should be pushed.</em></span>
        </p>
<p>
          When <code class="computeroutput"><span class="identifier">on_deserialize</span></code> is
          called, the feature may recover the lua value from the stack, which it
          will find on top. It should use the value to restore its internal state,
          <span class="emphasis"><em>then pop the value</em></span>.
        </p>
<p>
          A feature which also has these two methods is called a <span class="bold"><strong>serial
          feature</strong></span>.
        </p>
<h5>
<a name="lua_primer.reference.api.api_feature.h1"></a>
          <span><a name="lua_primer.reference.api.api_feature.behavior"></a></span><a class="link" href="api_feature.html#lua_primer.reference.api.api_feature.behavior">Behavior</a>
        </h5>
<p>
          When <code class="computeroutput"><span class="identifier">api</span><span class="special">::</span><span class="identifier">base</span><span class="special">::</span><span class="identifier">persist</span></code> is called, the permanent objects
          table is constructed by calling <code class="computeroutput"><span class="identifier">on_persist_table</span></code>
          for each API feature, and the target table is constructed using <code class="computeroutput"><span class="identifier">_G</span></code>, <span class="emphasis"><em>and each of the values
          provided by an API feature which has an <code class="computeroutput"><span class="identifier">on_serialize</span></code>
          method</em></span>.
        </p>
<p>
          When <code class="computeroutput"><span class="identifier">api</span><span class="special">::</span><span class="identifier">base</span><span class="special">::</span><span class="identifier">unpersist</span></code> is called, the reverse-permanent
          objects table is constructed first using <code class="computeroutput"><span class="identifier">on_unpersist_table</span></code>,
          and then the target table is reconstructed from the given string. Then,
          each API feature with an <code class="computeroutput"><span class="identifier">on_deserialize</span></code>
          method is <span class="emphasis"><em>passed back the object which it pushed</em></span> onto
          the stack, in order to restore its internal state. And the reproduced image
          of <code class="computeroutput"><span class="identifier">_G</span></code> replaces the current
          value of <code class="computeroutput"><span class="identifier">_G</span></code>.
        </p>
<h5>
<a name="lua_primer.reference.api.api_feature.h2"></a>
          <span><a name="lua_primer.reference.api.api_feature.examples"></a></span><a class="link" href="api_feature.html#lua_primer.reference.api.api_feature.examples">Examples</a>
        </h5>
<p>
          For example, a feature that represents a custom lua library should install
          the library into the lua state when <code class="computeroutput"><span class="identifier">on_initialize</span></code>
          is called.
        </p>
<p>
          When <code class="computeroutput"><span class="identifier">on_persist_table</span></code> is
          called, it should add each function pointer and a name for it, using the
          function pointer as a key, to the given table (assumed to be on top of
          the stack).
        </p>
<p>
          When <code class="computeroutput"><span class="identifier">on_unpersist_table</span></code>
          is called, it should do the same, but in reverse, putting the name as the
          key.
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">my_functions</span> <span class="special">{</span>
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">luaL_Reg</span><span class="special">,</span> <span class="number">3</span><span class="special">&gt;</span> <span class="identifier">get_funcs</span><span class="special">()</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="special">{{</span><span class="string">"foo"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">foo</span><span class="special">},</span> <span class="special">{</span><span class="string">"bar"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">bar</span><span class="special">},</span> <span class="special">{</span><span class="string">"baz"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">baz</span><span class="special">}};</span>
  <span class="special">}</span>

  <span class="keyword">void</span> <span class="identifier">on_init</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*</span> <span class="identifier">L</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">lua_rawgeti</span><span class="special">(</span><span class="identifier">L</span><span class="special">,</span> <span class="identifier">LUA_REGISTRYINDEX</span><span class="special">,</span> <span class="identifier">LUA_RIDX_GLOBALS</span><span class="special">);</span>
    <span class="identifier">primer</span><span class="special">::</span><span class="identifier">set_funcs</span><span class="special">(</span><span class="identifier">L</span><span class="special">,</span> <span class="identifier">get_funcs</span><span class="special">());</span>
    <span class="comment">// ^ similar to luaL_setfuncs</span>
  <span class="special">}</span>

  <span class="keyword">void</span> <span class="identifier">on_persist_table</span><span class="special">(</span><span class="identifier">lua_STate</span> <span class="special">*</span> <span class="identifier">L</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">primer</span><span class="special">::</span><span class="identifier">set_funcs_reverse</span><span class="special">(</span><span class="identifier">L</span><span class="special">,</span> <span class="identifier">get_funcs</span><span class="special">());</span>
  <span class="special">}</span>

  <span class="keyword">void</span> <span class="identifier">on_unpersist_table</span><span class="special">(</span><span class="identifier">lua_STate</span> <span class="special">*</span> <span class="identifier">L</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">primer</span><span class="special">::</span><span class="identifier">set_funcs</span><span class="special">(</span><span class="identifier">L</span><span class="special">,</span> <span class="identifier">get_funcs</span><span class="special">());</span>
  <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
          A different feature might use these methods in a totally different way.
        </p>
<p>
          For instance, suppose your api requires having a single unique userdata
          object which is globally visible to scripts and serves some important purpose.
        </p>
<p>
          The <code class="computeroutput"><span class="identifier">on_initialize</span></code> method
          might install this object, and also store a hidden reference to it in the
          lua registry so that you can find it again.
        </p>
<p>
          The <code class="computeroutput"><span class="identifier">on_persist_table</span></code> method
          might fetch the reference from the registry and map that object to some
          name <code class="computeroutput"><span class="string">"my_awesome_object"</span></code>.
          Then in the unpersist table, you can map <code class="computeroutput"><span class="string">"my_awesome_object"</span></code>
          back to the new instance of that object in a recreated VM.
        </p>
<p>
          An API feature is a <span class="bold"><strong>data member</strong></span> of the
          API object. This allows it to have private variables, nontrivial initialization,
          links to other objects in your C++ program, and for any methods that it
          install in the lua state to have potentially have additional useful side-effects
          in your program.
        </p>
<p>
          Examples of functionalities that Primer has built-in API Features for include
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Standard Lua Libraries
            </li>
<li class="listitem">
              Userdata types
            </li>
<li class="listitem">
              Virtual filesystem (for <code class="computeroutput"><span class="identifier">loadfile</span></code>,
              <code class="computeroutput"><span class="identifier">dofile</span></code>, <code class="computeroutput"><span class="identifier">require</span></code>)
            </li>
<li class="listitem">
              Print redirect / Interpreter Dialog interaction
            </li>
<li class="listitem">
              Persistent C++ values
            </li>
</ul></div>
<p>
          However, anything matching the concept can be used -- the methods are just
          hooks that you can use into the serialization process in an organized,
          object-oriented manner.
        </p>
<h5>
<a name="lua_primer.reference.api.api_feature.h3"></a>
          <span><a name="lua_primer.reference.api.api_feature.other"></a></span><a class="link" href="api_feature.html#lua_primer.reference.api.api_feature.other">Other</a>
        </h5>
<p>
          To assert that a type declares the proper member functions to be an API
          feature, you can use a <code class="computeroutput"><span class="keyword">static_assert</span></code>
          like this:
        </p>
<pre class="programlisting"><span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">primer</span><span class="special">::</span><span class="identifier">api</span><span class="special">::</span><span class="identifier">is_feature</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">"T does not match the API_FEATURE concept!"</span><span class="special">);</span>
</pre>
<p>
          To assert that it further is a "serial feature" containing the
          <code class="computeroutput"><span class="identifier">on_serialize</span></code> and <code class="computeroutput"><span class="identifier">on_deserialize</span></code> methods, you can use the
          <code class="computeroutput"><span class="identifier">is_serial_feature</span> <span class="identifier">trait</span></code>:
        </p>
<pre class="programlisting"><span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">primer</span><span class="special">::</span><span class="identifier">api</span><span class="special">::</span><span class="identifier">is_serial_feature</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span> <span class="string">"T does not match the serial feature concept!"</span><span class="special">);</span>
</pre>
<p>
          If a type is recognized as a feature but not a serial feature, because
          it has only one of <code class="computeroutput"><span class="identifier">on_serialize</span></code>
          and <code class="computeroutput"><span class="identifier">on_deserialize</span></code>, it
          will just be silently used as an API feature, so for debugging purposes
          the above assertion is sometimes useful.
        </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="concepts.html"><img src="../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../api.html"><img src="../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="api_library.html"><img src="../../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
