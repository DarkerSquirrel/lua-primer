<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>API Feature</title>
<link rel="stylesheet" href="../../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../../index.html" title="Chapter&#160;1.&#160;Lua Primer 0.0">
<link rel="up" href="../api.html" title="API">
<link rel="prev" href="api_userdata.html" title="API Userdata">
<link rel="next" href="api_callback.html" title="API Callback">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="api_userdata.html"><img src="../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../api.html"><img src="../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="api_callback.html"><img src="../../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="lua_primer.reference.api.api_feature"></a><a class="link" href="api_feature.html" title="API Feature">API Feature</a>
</h4></div></div></div>
<p>
          An API feature is an object which is responsible to install some feature
          within a lua State, and to provide support when we want to serialize /
          deserialize the state.
        </p>
<p>
          A basic API feature object has three important methods:
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">my_feature</span> <span class="special">{</span>
  <span class="keyword">void</span> <span class="identifier">on_initialize</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
  <span class="keyword">void</span> <span class="identifier">on_persist_table</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
  <span class="keyword">void</span> <span class="identifier">on_unpersist_table</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
<span class="special">};</span>
</pre>
<p>
          The <code class="computeroutput"><span class="identifier">on_initialize</span></code> method
          is called when the API is initialized.
        </p>
<p>
          The <code class="computeroutput"><span class="identifier">on_persist_table</span></code> method
          is called when we are persisting the state, and need to construct the permanent
          objects table. When called, your feature will get a state, and can assume
          that the permanent objects table is on top of the stack. It should register
          each object, using the object as the key, and a serialization name as the
          value.
        </p>
<p>
          The <code class="computeroutput"><span class="identifier">on_unpersist_table</span></code>
          method is the same, but it does the reverse. The key should be the serialization
          name, and the value should be the object.
        </p>
<p>
          Usually, permanent objects are just function pointers, but occasionally
          they might be something else. For instance if there is a global userdata
          of some type, it could be serialized by putting it in the permanent objects
          table, rather than providing a <code class="computeroutput"><span class="identifier">__persist</span></code>
          metamethod.
        </p>
<h4>
<a name="lua_primer.reference.api.api_feature.h0"></a>
          <span><a name="lua_primer.reference.api.api_feature.additional_methods"></a></span><a class="link" href="api_feature.html#lua_primer.reference.api.api_feature.additional_methods">Additional
          methods</a>
        </h4>
<p>
          A complex feature may not only add objects to lua, it may also have some
          internal state that supports some of the functionalities. In that case,
          the internal state needs to be serialized as well, not just what is visible
          to scripts via the global table.
        </p>
<p>
          To support this, the API feature can declare itself to be "serial",
          and define methods "on_serialize" and "on_deserialize".
        </p>
<p>
          When <code class="computeroutput"><span class="identifier">on_serialize</span></code> is called,
          the feature should push one lua value onto the stack which will be associated
          to it and saved. It may be a complex table or any other thing that primer
          is able to serialize. <span class="emphasis"><em>Exactly one value should be pushed.</em></span>
        </p>
<p>
          When <code class="computeroutput"><span class="identifier">on_deserialize</span></code> is
          called, the feature may recover the lua value from the stack, which it
          will find on top. It should use the value to restore its internal state,
          <span class="emphasis"><em>then pop the value</em></span>.
        </p>
<p>
          If it defines these methods, the feature should make a declaration <code class="computeroutput"><span class="keyword">static</span> <span class="keyword">constexpr</span>
          <span class="keyword">bool</span> <span class="identifier">is_serial</span>
          <span class="special">=</span> <span class="keyword">true</span></code>.
          This signals to primer that it produces serialization data -- those two
          calls will be skipped if it doesn't have this.
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">my_second_feature</span> <span class="special">{</span>
  <span class="keyword">void</span> <span class="identifier">on_initialize</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
  <span class="keyword">void</span> <span class="identifier">on_persist_table</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
  <span class="keyword">void</span> <span class="identifier">on_unpersist_table</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
  <span class="keyword">void</span> <span class="identifier">on_serialize</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>
  <span class="keyword">void</span> <span class="identifier">on_deserialize</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*);</span>

  <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="identifier">is_serial</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
<span class="special">};</span>
</pre>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="api_userdata.html"><img src="../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../api.html"><img src="../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="api_callback.html"><img src="../../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
