<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Motivation</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Lua Primer 0.0">
<link rel="up" href="../overview.html" title="Overview">
<link rel="prev" href="../overview.html" title="Overview">
<link rel="next" href="design.html" title="Design">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="design.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="lua_primer.overview.motivation"></a><a class="link" href="motivation.html" title="Motivation">Motivation</a>
</h3></div></div></div>
<p>
        Lua is a popular scripting language. The standard lua implementation is written
        in C, and provides several facilities to permit application writers to create
        APIs or "bindings", by exposing their functions and objects to
        lua.
      </p>
<p>
        In the lua C api, the handle to a lua VM is an opaque pointer of type <code class="computeroutput"><span class="identifier">lua_State</span> <span class="special">*</span></code>.
      </p>
<p>
        Functions are exposed to a VM by creating a C-style function with signature
        <code class="computeroutput"><span class="keyword">int</span> <span class="special">(</span><span class="identifier">lua_State</span><span class="special">*)</span></code>,
        and pushing a pointer to this function to lua, e.g.:
      </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="identifier">lua_CFunction</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">(*)(</span><span class="identifier">lua_State</span> <span class="special">*);</span>

<span class="keyword">void</span> <span class="identifier">lua_pushcfunction</span> <span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*</span> <span class="identifier">L</span><span class="special">,</span> <span class="identifier">lua_CFunction</span> <span class="identifier">f</span><span class="special">);</span>

<span class="comment">// Pushes a C function onto the stack. This function receives a pointer to a C</span>
<span class="comment">// function and pushes onto the stack a Lua value of type function that, when</span>
<span class="comment">// called, invokes the corresponding C function. </span>
</pre>
<p>
        Objects are exposed by creating a "userdata" object with the lua
        VM. A userdata object represents a block of memory allocated by the lua VM,
        in which you can construct your object. Then, you assign may assign a lua
        "metatable" which can give the object custom methods and semantics,
        and provide for cleanup when the object is garbage collected.
      </p>
<p>
        There are two basic challenges in using this interface with C++ code.
      </p>
<h3>
<a name="lua_primer.overview.motivation.h0"></a>
        <span><a name="lua_primer.overview.motivation.binding"></a></span><a class="link" href="motivation.html#lua_primer.overview.motivation.binding">Binding</a>
      </h3>
<p>
        The first is that, it is somewhat inconvenient to write all your functions
        as <code class="computeroutput"><span class="keyword">int</span> <span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*)</span></code>.
        This requires the programmer to manually read arguments to the function off
        the stack and perform standard error reporting for each function. Additionally,
        it forces the function to be a "free"-function, which is at odds
        with an object-oriented programming style. Usually, in a well-designed program,
        not all of the resources will be allocated in global variables, so the function
        which is passed to lua must somehow obtain a handle to the resources that
        it is supposed to use to carry out its task.
      </p>
<p>
        This is generally solved by using templates to create generic "delegates"
        which can be passed to lua comfortably. A template is created which can take
        a function pointer of a more general signature, or a pointer to member function.
        Generic code is written which parses the arguments off the stack and signals
        an error. In the case of a member function, some mechanism must be used to
        store and recover a pointer to the correct base object, which can be recovered
        from lua so that the appropriate method can be invoked. There are several
        possible strategies for this -- for examples of popular open-source libraries
        which accomplish this, look at <a href="https://github.com/luabind/luabind" target="_top">luabind</a>
        or <a href="https://github.com/vinniefalco/LuaBridge" target="_top">LuaBridge</a>.
      </p>
<p>
        For concreteness, LuaBridge registration syntax for functions and variables
        looks like this:
      </p>
<pre class="programlisting"><span class="identifier">LuaBridge</span><span class="special">::</span><span class="identifier">getGlobalNamespace</span> <span class="special">(</span><span class="identifier">L</span><span class="special">)</span>
  <span class="special">.</span><span class="identifier">beginNamespace</span> <span class="special">(</span><span class="string">"test"</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">addVariable</span> <span class="special">(</span><span class="string">"var1"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">globalVar</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">addVariable</span> <span class="special">(</span><span class="string">"var2"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">staticVar</span><span class="special">,</span> <span class="keyword">false</span><span class="special">)</span>     <span class="comment">// read-only</span>
    <span class="special">.</span><span class="identifier">addProperty</span> <span class="special">(</span><span class="string">"prop1"</span><span class="special">,</span> <span class="identifier">getString</span><span class="special">,</span> <span class="identifier">setString</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">addProperty</span> <span class="special">(</span><span class="string">"prop2"</span><span class="special">,</span> <span class="identifier">getString</span><span class="special">)</span>            <span class="comment">// read only</span>
    <span class="special">.</span><span class="identifier">addFunction</span> <span class="special">(</span><span class="string">"foo"</span><span class="special">,</span> <span class="identifier">foo</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">addFunction</span> <span class="special">(</span><span class="string">"bar"</span><span class="special">,</span> <span class="identifier">bar</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">addCFunction</span> <span class="special">(</span><span class="string">"cfunc"</span><span class="special">,</span> <span class="identifier">cFunc</span><span class="special">)</span>
  <span class="special">.</span><span class="identifier">endNamespace</span> <span class="special">();</span>
</pre>
<p>
        and for classes looks like this:
      </p>
<pre class="programlisting"><span class="identifier">LuaBridge</span><span class="special">::</span><span class="identifier">getGlobalNamespace</span> <span class="special">(</span><span class="identifier">L</span><span class="special">)</span>
  <span class="special">.</span><span class="identifier">beginNamespace</span> <span class="special">(</span><span class="string">"test"</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">beginClass</span> <span class="special">&lt;</span><span class="identifier">A</span><span class="special">&gt;</span> <span class="special">(</span><span class="string">"A"</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addStaticData</span> <span class="special">(</span><span class="string">"staticData"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">staticData</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addStaticProperty</span> <span class="special">(</span><span class="string">"staticProperty"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">staticProperty</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addStaticFunction</span> <span class="special">(</span><span class="string">"staticFunc"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">staticFunc</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addStaticCFunction</span> <span class="special">(</span><span class="string">"staticCFunc"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">staticCFunc</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addData</span> <span class="special">(</span><span class="string">"data"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">dataMember</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addProperty</span> <span class="special">(</span><span class="string">"prop"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">getProperty</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">setProperty</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addFunction</span> <span class="special">(</span><span class="string">"func1"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">func1</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addFunction</span> <span class="special">(</span><span class="string">"virtualFunc"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">virtualFunc</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addCFunction</span> <span class="special">(</span><span class="string">"cfunc"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">cfunc</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">endClass</span> <span class="special">()</span>
    <span class="special">.</span><span class="identifier">deriveClass</span> <span class="special">&lt;</span><span class="identifier">B</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span> <span class="special">(</span><span class="string">"B"</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addData</span> <span class="special">(</span><span class="string">"data"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">B</span><span class="special">::</span><span class="identifier">dataMember2</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addFunction</span> <span class="special">(</span><span class="string">"func1"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">B</span><span class="special">::</span><span class="identifier">func1</span><span class="special">)</span>
      <span class="special">.</span><span class="identifier">addFunction</span> <span class="special">(</span><span class="string">"func2"</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">B</span><span class="special">::</span><span class="identifier">func2</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">endClass</span> <span class="special">()</span>
  <span class="special">.</span><span class="identifier">endNameSpace</span> <span class="special">();</span>
</pre>
<p>
        In other words, LuaBridge is providing various bindings proxy objects which
        provide templated member functions to carry out bindings tasks, taking function
        pointers of arbitrary signatures and wrapping them appropriately to get a
        <code class="computeroutput"><span class="keyword">int</span> <span class="special">(</span><span class="identifier">luaState</span><span class="special">*)</span></code>
        which can be passed to lua.
      </p>
<h3>
<a name="lua_primer.overview.motivation.h1"></a>
        <span><a name="lua_primer.overview.motivation.serialization"></a></span><a class="link" href="motivation.html#lua_primer.overview.motivation.serialization">Serialization</a>
      </h3>
<p>
        The second challenge has to do with <span class="bold"><strong>serializing</strong></span>
        the lua VM and restoring it.
      </p>
<p>
        The lua developers generally take a very conservative approach to exposing
        language features in lua, or in adding features to its standard libraries.
        For instance, there is no built-in function which prints the contents of
        a table to the screen, or which copies a table.
      </p>
<div class="blockquote"><blockquote class="blockquote"><p>
          There is no copy function sufficiently widely agreed upon to be called
          "standard". <span class="emphasis"><em>--Norman Ramsey</em></span>
        </p></blockquote></div>
<p>
        Should it be deep-copying, or shallow copying? How should it handle metatables?
        What exactly does deep-copying mean, given that some types are inherently
        opaque and not copyable (userdata, functions). What if the table structure
        is recursive?
      </p>
<p>
        Instead, users are encouraged to roll their own quick copy / print functions
        and so on, as the language is quite expressive and it is easy to do this
        for simple purposes in pure lua.
      </p>
<p>
        For instance, here's an example that does a "recursive" deep-copy
        of a table, <a href="http://stackoverflow.com/questions/640642/how-do-you-copy-a-lua-table-by-value" target="_top">c.f.
        stackoverflow</a>.
      </p>
<pre class="programlisting"><span class="identifier">function</span> <span class="identifier">copy</span><span class="special">(</span><span class="identifier">obj</span><span class="special">,</span> <span class="identifier">seen</span><span class="special">)</span>
  <span class="keyword">if</span> <span class="identifier">type</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span> <span class="special">~=</span> <span class="char">'table'</span> <span class="identifier">then</span> <span class="keyword">return</span> <span class="identifier">obj</span> <span class="identifier">end</span>
  <span class="keyword">if</span> <span class="identifier">seen</span> <span class="keyword">and</span> <span class="identifier">seen</span><span class="special">[</span><span class="identifier">obj</span><span class="special">]</span> <span class="identifier">then</span> <span class="keyword">return</span> <span class="identifier">seen</span><span class="special">[</span><span class="identifier">obj</span><span class="special">]</span> <span class="identifier">end</span>
  <span class="identifier">local</span> <span class="identifier">s</span> <span class="special">=</span> <span class="identifier">seen</span> <span class="keyword">or</span> <span class="special">{}</span>
  <span class="identifier">local</span> <span class="identifier">res</span> <span class="special">=</span> <span class="identifier">setmetatable</span><span class="special">({},</span> <span class="identifier">getmetatable</span><span class="special">(</span><span class="identifier">obj</span><span class="special">))</span>
  <span class="identifier">s</span><span class="special">[</span><span class="identifier">obj</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">res</span>
  <span class="keyword">for</span> <span class="identifier">k</span><span class="special">,</span> <span class="identifier">v</span> <span class="identifier">in</span> <span class="identifier">pairs</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span> <span class="keyword">do</span> <span class="identifier">res</span><span class="special">[</span><span class="identifier">copy</span><span class="special">(</span><span class="identifier">k</span><span class="special">,</span> <span class="identifier">s</span><span class="special">)]</span> <span class="special">=</span> <span class="identifier">copy</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">s</span><span class="special">)</span> <span class="identifier">end</span>
  <span class="keyword">return</span> <span class="identifier">res</span>
<span class="identifier">end</span>
</pre>
<p>
        This function attempts to copy a table, making analogous copies of each constituent
        table, while preserving the referential structure. That is if <code class="computeroutput"><span class="identifier">obj</span><span class="special">.</span><span class="identifier">x</span></code>
        and <code class="computeroutput"><span class="identifier">obj</span><span class="special">.</span><span class="identifier">y</span></code> were both references to the same table,
        then they will be references to an analaogous table, in the result.
      </p>
<p>
        This works well when the only types we consider are tables and primitive
        values. What about the case of functions, or specifically, closures? In lua,
        it is easy to create lexical closures, which capture and extend the lifetime
        of any objects in their scope. If those objects then go out of the global
        scope, i.e., if the function is returned by another function, then the objects
        essentially become "private property" of the closure. This is somewhat
        like C++ lambda capture. These captured values are called "upvalues"
        of the closure, in lua documentation.
      </p>
<p>
        When copying a closure, should we also "copy" the upvalues? How
        can we, given that we cannot even access them from "outside" of
        the closure?
      </p>
<p>
        In this case, a solution can be achieved with the help of the <code class="computeroutput"><span class="identifier">debug</span></code> library. The debug library is a standard
        library in lua which contains some additional functionality for help in writing
        debuggers. The debug library contains some low-level functions which allow
        to access the byte-code associated to a lua function, as well as to access
        the up-values of a closure. Here's a code snippet from <a href="http://lua-users.org/wiki/DataDumper" target="_top">Data
        Dumper</a>, a more sophisticated copying / serializing mechanism.
      </p>
<pre class="programlisting"><span class="identifier">local</span> <span class="identifier">dumplua_closure</span> <span class="special">=</span> <span class="special">[[</span>
<span class="identifier">local</span> <span class="identifier">closures</span> <span class="special">=</span> <span class="special">{}</span>
<span class="identifier">local</span> <span class="identifier">function</span> <span class="identifier">closure</span><span class="special">(</span><span class="identifier">t</span><span class="special">)</span>
  <span class="identifier">closures</span><span class="special">[#</span><span class="identifier">closures</span><span class="special">+</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">t</span>
  <span class="identifier">t</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">assert</span><span class="special">(</span><span class="identifier">loadstring</span><span class="special">(</span><span class="identifier">t</span><span class="special">[</span><span class="number">1</span><span class="special">]))</span>
  <span class="keyword">return</span> <span class="identifier">t</span><span class="special">[</span><span class="number">1</span><span class="special">]</span>
<span class="identifier">end</span>

<span class="keyword">for</span> <span class="identifier">_</span><span class="special">,</span><span class="identifier">t</span> <span class="identifier">in</span> <span class="identifier">pairs</span><span class="special">(</span><span class="identifier">closures</span><span class="special">)</span> <span class="keyword">do</span>
  <span class="keyword">for</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">2</span><span class="special">,#</span><span class="identifier">t</span> <span class="keyword">do</span>
    <span class="identifier">debug</span><span class="special">.</span><span class="identifier">setupvalue</span><span class="special">(</span><span class="identifier">t</span><span class="special">[</span><span class="number">1</span><span class="special">],</span> <span class="identifier">i</span><span class="special">-</span><span class="number">1</span><span class="special">,</span> <span class="identifier">t</span><span class="special">[</span><span class="identifier">i</span><span class="special">])</span>
  <span class="identifier">end</span>
<span class="identifier">end</span>
<span class="special">]]</span>
</pre>
<p>
        However, this solution may be unsatisfactory for several reasons. For one,
        you often don't want to expose the debug library to user scripts. Doing so
        breaks encapsulation, as now the user can grab the private variables of any
        closure or library function. It allows them to do other intrusive things
        which usually the user doesn't want or need to do, and generally can make
        it harder to reason about your code.
      </p>
<p>
        Second, the debug library doesn't actually completely solve such problems.
        For instance, it doesn't provide you sufficiently powerful tools to examine
        the state of suspended threads such that you can duplicate them. "Suspended
        threads" may sound like a pretty unimportant edge case, but actually,
        it is pretty common in some lua libraries to use lua coroutines to implement
        custom iterators. In this case, any such iterator is actually a closure which
        contains a suspended thread as an upvalue.
      </p>
<p>
        From the application developer's point of view, the lack of built-in support
        for "magic-bullet" serialization is understandable, but disappointing.
        On the one hand, many other scripting languages like Python and Ruby don't
        provide this either. On the other hand, lua is quite commonly used in games,
        or for scripting the operation of a webserver. For many kinds of games, it's
        pretty important to be able to save and restore the game accurately. For
        the case of a server, you may want to be able to suspend the operation of
        the server, and seamlessly relaunch the process on a different server, for
        purposes of load balancing.
      </p>
<p>
        If one is using a hand-rolled serialization function which handles "most
        but not all" datatypes that can occur in a lua state, the result is
        pretty disasterous.
      </p>
<p>
        In the case of a game, the user is told
      </p>
<div class="blockquote"><blockquote class="blockquote"><p>
          "the game could not be saved because (obscure lua type system message)"
        </p></blockquote></div>
<p>
        Or, worse, the game appears to be saved, but on restoration, some parts are
        subtly incorrect.
      </p>
<p>
        In the case of a server, the system may work great for years with "simple"
        scripts, and then one day a clever programmer is developing the application
        and constructs a type which goes just out of bounds of the assumptions of
        the serialization script, and now he gets down-time or corrupted states at
        runtime, when serialization is actually attempted.
      </p>
<p>
        In such applications, it is very desirable to have a comprehensive serialization
        solution which one can confidently deploy, which can handle correctly any
        possible state.
      </p>
<p>
        In strategy games, this is so important that in many cases the developer
        may choose to avoid technologies like Lua and Python, and instead just role
        their own small scripting language in C++, which they know can be easily
        serialized and restored, by virtue of using only transparent C++ data structures
        in its implementation.
      </p>
<h3>
<a name="lua_primer.overview.motivation.h2"></a>
        <span><a name="lua_primer.overview.motivation.eris"></a></span><a class="link" href="motivation.html#lua_primer.overview.motivation.eris">Eris</a>
      </h3>
<p>
        Lua is unique in that the core language really is significantly smaller than
        that of technologies like Python and Ruby, and its implementation is very
        small and clean. As a result, Lua enjoys a very robust approach to serialization,
        which is the technique created first by "Pluto" and later by "Eris".
        <a href="http://lua-users.org/wiki/PlutoLibrary" target="_top">Pluto</a> and <a href="https://github.com/fnuecke/eris" target="_top">Eris</a> are essentially a small
        body of patches to the core lua implementation, which create a "heavy-duty"
        persistence capability. These patches dig into the core libraries in order
        to gain access to the various "anonymous" functions that lua may
        push into its state, in order to support their serialization, and they are
        able to serialize closures and threads directly, without accessing them via
        the debug library.
      </p>
<p>
        Pluto was developed to support lua 5.1. Eris is a rewrite of Pluto that supports
        lua 5.2 and 5.3. Both are robust technologies, widely used by applications
        that need this capability. They have a collection of unit tests and are regularly
        updated as new versions of lua are released.
      </p>
<h3>
<a name="lua_primer.overview.motivation.h3"></a>
        <span><a name="lua_primer.overview.motivation.eris_bindings"></a></span><a class="link" href="motivation.html#lua_primer.overview.motivation.eris_bindings">Eris
        + Bindings?</a>
      </h3>
<p>
        Eris is able on its own to serialize essentially any "natural"
        lua object, i.e., that arises by using the built-in lua features and libraries.
        However, some objects are inherently opaque -- function pointers to functions
        from your application, and userdata types created by your application.
      </p>
<p>
        To handle such objects, Eris requires you to provide a table called the "permanent
        objects table". For objects like function pointers, you are required
        to create an entry for them in the permanent objects table which gives them
        an easily-serialized alias. Then, when the state is restored, you are required
        to provide the "inverse" of the permanent objects table, so that
        these aliases can be replaced with "new", properly-constructed,
        "corresponding" instances of those objects.
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">eris_persist</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*</span><span class="identifier">L</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">perms</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">value</span><span class="special">);</span> <span class="comment">// [-0, +1, e]</span>
<span class="comment">// It expects the permanent object table at the specified index perms and</span>
<span class="comment">// the value to persist at the specified index value. It will push the</span>
<span class="comment">// resulting binary string onto the stack on success.</span>

<span class="keyword">void</span> <span class="identifier">eris_unpersist</span><span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*</span><span class="identifier">L</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">perms</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">value</span><span class="special">);</span> <span class="comment">// [-0, +1, e]</span>
<span class="comment">// It expects the permanent object table at the specified index perms and</span>
<span class="comment">// the binary string containing persisted data at the specified index value.</span>
<span class="comment">// It will push the resulting value onto the stack on success.</span>
</pre>
<p>
        For userdata, oftentimes there may be a very large number of userdata of
        a given <span class="bold"><strong>class</strong></span> and it would be infeasible
        to add them all to the permanent objects table. Instead, you can create a
        special metamethod called <code class="computeroutput"><span class="identifier">__persist</span></code>.
        When eris needs to serialize your userdata type, it calls this method, and
        expects it to return a closure type, which will be serialized in place of
        the object. The closure should essentially be a call to some kind of "constructor"
        for this userdata type, together with appropriate arguments. Conveniently,
        it is okay for this constructor to be implemented in C / C++ rather than
        pure lua, so long as that function pointer is in the permanent objects table.
        Similarly, the upvalues may also be userdata or some other complex type,
        so long as it is possible to serialize them with support from the permanent
        objects table.
      </p>
<p>
        This is all well and good. As long as you can keep track of any "foreign
        material" that you add to a lua State and add it to the permanent objects
        table, and give your userdata types a <code class="computeroutput"><span class="identifier">__persist</span></code>
        method and also put the constructor functions that they use in the permanent
        objects table, then you can save and restore faithfully.
      </p>
<p>
        While from the point of view of Eris, the contract of use is pretty simple,
        from the point of view of a large C++ application with a complex API, there
        are some difficulties with using this interface directly.
      </p>
<h4>
<a name="lua_primer.overview.motivation.h4"></a>
        <span><a name="lua_primer.overview.motivation.where_are_the_function_pointers"></a></span><a class="link" href="motivation.html#lua_primer.overview.motivation.where_are_the_function_pointers">Where
        are the function pointers?</a>
      </h4>
<p>
        The first is that if you are using a binding system like <code class="computeroutput"><span class="identifier">luabind</span></code>
        or <code class="computeroutput"><span class="identifier">LuaBridge</span></code>, often you don't
        really have the function pointers on hand -- those are hidden from you by
        the binding system, which seeks to give you the most elegant syntax possible
        and hide the plumbing. It may be very difficult to dig these pointers out
        so that you can put them into the permanent objects table.
      </p>
<h4>
<a name="lua_primer.overview.motivation.h5"></a>
        <span><a name="lua_primer.overview.motivation.compile_time_vs_run_time_registr"></a></span><a class="link" href="motivation.html#lua_primer.overview.motivation.compile_time_vs_run_time_registr">Compile-time
        vs run-time registration</a>
      </h4>
<p>
        Even ignoring the issue of getting the function pointers, just keeping track
        of the function pointers and their aliases for a large C++ api is a actually
        pretty complex book-keeping problem that can lead to subtle runtime errors,
        if one just hacks away at it procedurally. All userdata, libraries, and global
        callbacks need to be registered at VM initialization, again at the permanent
        objects table, and again at the inverse permanent objects table. If one of
        these is missing, you may just get a runtime error on deserialization. It
        can easily become confusing, especially if there are several different lua
        APIs used for several different components in your application.
      </p>
<p>
        Ideally, one would like to solve this problem with a "lazy registration"
        strategy. I.e. make the permanent objects table as we go, only adding function
        pointers to it at the time that we actually push them into the lua state.
        This is most consistent with <code class="computeroutput"><span class="identifier">luabind</span></code>
        and <code class="computeroutput"><span class="identifier">LuaBridge</span></code> anyways, which
        view userdata and function registration as a <span class="bold"><strong>runtime</strong></span>
        event. However, this is broken with Eris -- we cannot afford to "experimentally
        determine" the permanent objects table, since when deserializing a lua
        VM, it's possible that this is the first VM we have created in this run of
        our application.
      </p>
<p>
        The most robust and reliable strategy, for using automatic lua bindings together
        with eris, seems to be to use a <span class="bold"><strong>compile-time</strong></span>
        registration system. This way, for any given API that we expose, we know
        exactly how to construct the permanent objects table for serialization and
        destructoin at compile time, and we can fail fast if the program attempts
        to push something to a lua VM that we don't know how to serialize.
      </p>
<h4>
<a name="lua_primer.overview.motivation.h6"></a>
        <span><a name="lua_primer.overview.motivation.concept_api_features"></a></span><a class="link" href="motivation.html#lua_primer.overview.motivation.concept_api_features">Concept:
        API Features</a>
      </h4>
<p>
        Primer ultimately organizes all such things, that is, lua callbacks, libraries,
        and userdata, under a C++ concept called an "api feature".
      </p>
<p>
        An API which is exposed to lua is constructed by creating a class which derives
        from <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">api</span><span class="special">::</span><span class="identifier">base</span></code>.
        The developer is expected to create a <code class="computeroutput"><span class="identifier">lua_State</span>
        <span class="special">*</span></code> within this class, perhaps stored
        as a member variable (or in whatever way you like). The <code class="computeroutput"><span class="identifier">api</span><span class="special">::</span><span class="identifier">base</span></code>
        object provides several ways to register member functions as lua callbacks
        which are part of the API. Other API features are represented by function
        objects which are members of the API, and the <code class="computeroutput"><span class="identifier">api</span><span class="special">::</span><span class="identifier">base</span></code>
        class provides a way to register them when they are declared.
      </p>
<p>
        The API class then inherits three member functions from <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">api</span><span class="special">::</span><span class="identifier">base</span></code>:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">initialize_api</span><span class="special">(</span><span class="identifier">lua_State</span>
            <span class="special">*);</span></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">persist</span><span class="special">(</span><span class="identifier">lua_State</span>
            <span class="special">*,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span>
            <span class="special">&amp;</span> <span class="identifier">buffer</span><span class="special">);</span></code>
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unpersist</span><span class="special">(</span><span class="identifier">lua_State</span>
            <span class="special">*,</span> <span class="keyword">const</span>
            <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&amp;</span>
            <span class="identifier">buffer</span><span class="special">);</span></code>
          </li>
</ul></div>
<p>
        The <code class="computeroutput"><span class="identifier">initialize_api</span></code> method
        asks each registered API feature to initialize itself within the given lua
        VM.
      </p>
<p>
        The <code class="computeroutput"><span class="identifier">persist</span></code> method serializes
        the global table, and any ancillary data associated to each registered feature,
        into a given string. The <code class="computeroutput"><span class="identifier">unpersist</span></code>
        method reconstructs a state from a given buffer, reassigns the global table,
        and provides ancillary data back to each api feature.
      </p>
<p>
        Primer provides classes for many commonly useful API features, including
        support for "special" persistent values which are stored in the
        registry and not in the global table, for attaching a VFS to a lua VM to
        replace the default filesystem access, attaching an interpreter temporarily
        to a lua VM, installing custom error handlers, custom libraries, and so on.
        But more generally, if you understand how the permanent objects table works,
        you can easily implement other API feature objects.
      </p>
<p>
        The most beneficial thing about the API feature concept is that it keeps
        the code associated to each feature separate, so you register the list of
        features once and don't end up with a procedural stew.
      </p>
<p>
        If the concept is too restrictive for a feature that need to add, fortunately,
        primer does not attempt to get between you and the lua VM. You can always
        do whatever initialization or setup you need outside of these functions,
        before or after the <code class="computeroutput"><span class="identifier">initialize_api</span></code>
        and <code class="computeroutput"><span class="identifier">persist</span></code> methods. The
        API features framework is there merely to assist in organization.
      </p>
<h3>
<a name="lua_primer.overview.motivation.h7"></a>
        <span><a name="lua_primer.overview.motivation.summary"></a></span><a class="link" href="motivation.html#lua_primer.overview.motivation.summary">Summary</a>
      </h3>
<p>
        Eris is a really nice and useful technology, and it is perfectly possible
        to use it with your C++ applications without using Primer. Primer just handles
        some of the book-keeping and plumbing for you. This lets you have the benefits
        of using a library like <span class="bold"><strong>luabind</strong></span> or <span class="bold"><strong>LuaBridge</strong></span> while also enjoying the power of <span class="bold"><strong>Eris</strong></span>.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="design.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
