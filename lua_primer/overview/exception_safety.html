<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Exception Safety</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Lua Primer 0.0">
<link rel="up" href="../overview.html" title="Overview">
<link rel="prev" href="build_configuration.html" title="Build Configuration">
<link rel="next" href="../reference.html" title="Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="build_configuration.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="../reference.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="lua_primer.overview.exception_safety"></a><a class="link" href="exception_safety.html" title="Exception Safety">Exception Safety</a>
</h3></div></div></div>
<p>
        Primer is designed with the following constraints in mind:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Primer should work whether lua is compiled as C or C++.
          </li>
<li class="listitem">
            Primer should not require C++ exceptions or RTTI to be enabled.
          </li>
</ul></div>
<p>
        We also take as a given that it is <span class="bold"><strong>not</strong></span> okay
        to throw foreign exceptions through lua, no matter how it is compiled.
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            c.f. <a href="http://lua-users.org/lists/lua-l/2007-10/msg00473.html" target="_top">http://lua-users.org/lists/lua-l/2007-10/msg00473.html</a>
            lua mailing list
          </li>
<li class="listitem">
            c.f. <a href="http://lua-users.org/wiki/ErrorHandlingBetweenLuaAndCplusplus" target="_top">http://lua-users.org/wiki/ErrorHandlingBetweenLuaAndCplusplus</a>
            lua users wiki
          </li>
<li class="listitem">
            c.f. <a href="http://stackoverflow.com/questions/4615890/how-to-handle-c-exceptions-when-calling-functions-from-lua" target="_top">http://stackoverflow.com/questions/4615890/how-to-handle-c-exceptions-when-calling-functions-from-lua</a>
            stackoverflow
          </li>
</ul></div>
<p>
        So, we don't throw any exceptions ourselves, and since many components of
        Primer are designed to be called by functions that will be passed to lua
        as function pointers, it's not a very good idea for them to be throwing exceptions
        either.
      </p>
<p>
        The places that exceptions can enter the picture break down roughly as follows:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            User code throws an exception into primer
            <div class="orderedlist"><ol class="orderedlist" type="a">
<li class="listitem">
                  A function which the user gave to primer to push to lua throws
                  an exception
                </li>
<li class="listitem">
                  An object which the user adapted for primer throws an exception
                  from its default constructor, move constructor, or move assignment
                  operator.
                </li>
<li class="listitem">
                  An object which the user adapted for primer, by specializing <code class="computeroutput"><span class="identifier">push</span></code> or <code class="computeroutput"><span class="identifier">read</span></code>,
                  throws an exception when it is pushed or read
                </li>
</ol></div>
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> is thrown
          </li>
</ol></div>
<p>
        Our exception-safety is not complete at the moment -- some of these are handled,
        and some of these can cause bad things to happen. Primer is a work-in-progress,
        and patches are welcome :)
      </p>
<p>
        The situations that we have a handle on are:
      </p>
<h5>
<a name="lua_primer.overview.exception_safety.h0"></a>
        <span><a name="lua_primer.overview.exception_safety.a_user_function_which_was_adapte"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.a_user_function_which_was_adapte">A
        user function which was adapted for lua throws an exception</a>
      </h5>
<p>
        This should never happen, and we view it as a bug in user code if it does.
      </p>
<p>
        If you throw an exception directly into lua, we consider that the stack can
        be corrupted and undefined behavior can result.
      </p>
<p>
        In Primer, we do not attempt to catch and handle your exceptions either.
        Instead, one of the functions in the "adapt" mechanism is marked
        <code class="computeroutput"><span class="keyword">noexcept</span></code>, which means that
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">terminate</span></code> will be called if your adapted
        function throws.
      </p>
<p>
        Note that this is different from how some libraries like <code class="computeroutput"><span class="identifier">LuaBridge</span></code>
        work, which attempt to stash away your exceptions, signal them to lua as
        a lua error, and rethrow them on the other side. We consider this to be not
        a very robust solution, and don't plan to do something like this in primer.
        If you want to create something like this, you are welcome to specialize
        the <code class="computeroutput"><span class="identifier">adaptor</span></code> class to do it.
      </p>
<h5>
<a name="lua_primer.overview.exception_safety.h1"></a>
        <span><a name="lua_primer.overview.exception_safety.an_object_which_the_user_adapted"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.an_object_which_the_user_adapted">An
        object which the user adapted for primer throws an exception from its default
        constructor, move constructor, or move assignment operator</a>
      </h5>
<p>
        This also should not happen -- objects that you want to push or read from
        primer should be nothrow move-constructible.
      </p>
<p>
        In certain circumstances related to containers (the <code class="computeroutput"><span class="identifier">visit_struct</span></code>
        mechanism, the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">array</span></code> mechanism), they must additionally
        be nothrow default constructible and nothrow move assignable. There are some
        fallbacks built into the system, in case they are not quite nothrow move
        assignable.
      </p>
<p>
        In general, the necessary preconditions are checked via <code class="computeroutput"><span class="keyword">static_assert</span></code>
        and your code won't compile if the assumptions aren't met.
      </p>
<p>
        For instance, <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">expected</span></code> is an exception-safe container
        in the strong sense. It's just that if your type is not <code class="computeroutput"><span class="identifier">nothrow_move_constructible</span></code>
        then you cannot compile.
      </p>
<h5>
<a name="lua_primer.overview.exception_safety.h2"></a>
        <span><a name="lua_primer.overview.exception_safety.a_specialization_of_push_or_read"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.a_specialization_of_push_or_read">A
        specialization of <code class="computeroutput"><span class="identifier">push</span></code> or
        <code class="computeroutput"><span class="identifier">read</span></code> throws an exception</a>
      </h5>
<p>
        Currently, we assume that pushing an object cannot fail.
      </p>
<p>
        Reading an object can fail, but it should return <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">error</span></code>
        in that case.
      </p>
<p>
        These functions are not supposed to throw exceptions, and currently it is
        considered a bug if they do.
      </p>
<p>
        There is no mechanism in place right now to make a <code class="computeroutput"><span class="keyword">static_assert</span></code>
        that they are <code class="computeroutput"><span class="keyword">noexcept</span></code>. That
        is something that we might add in the future.
      </p>
<p>
        That being said...
      </p>
<h5>
<a name="lua_primer.overview.exception_safety.h3"></a>
        <span><a name="lua_primer.overview.exception_safety.std_bad_alloc"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.std_bad_alloc"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code></a>
      </h5>
<p>
        There are a few known situations in primer that we do things that can cause
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> to be thrown, and don't have
        proper handling for it. For instance, when constructing a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
        from a C-string obtained from lua, or when calling <code class="computeroutput"><span class="identifier">emplace_back</span></code>
        on a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>.
      </p>
<p>
        The consequences of this can currently include:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Primer losing track of objects that it pushed onto the lua stack. If
            this happens repeatedly, you can run out of space on the lua stack and
            get a lua panic.
          </li>
<li class="listitem">
            An exception being thrown into the adapt mechanism, causing the program
            to be terminated.
          </li>
</ul></div>
<p>
        We also don't currently handle properly some errors that can occur when
        <span class="emphasis"><em>lua</em></span> runs out of memory. For instance, <code class="computeroutput"><span class="identifier">lua_pushstring</span></code> can fail, only in the scenario
        that lua cannot allocate enough memory. This could potentially cause a <code class="computeroutput"><span class="identifier">longjmp</span></code> and the leaking of objects on the
        C++ stack.
      </p>
<p>
        In many game projects, developers don't care about exception-safety in regards
        to out-of-memory problems. They prefer to write a custom allocator, periodically
        check to see if it is close to running out of memory, and in the rest of
        the code, assume that allocation always succeeds, since this can lead to
        some performance gain. I believe that for purposes of such projects, primer
        is essentially working correctly right now in regards to exception safety.
        That is, we <span class="bold"><strong>are</strong></span> correct in the face of exceptions,
        if we exclude the scenarios in which lua or the C++ standard allocator runs
        out of memory.
      </p>
<p>
        As a long-term goal, we would like to be able to provide correctness even
        in the face of out-of-memory errors. Perhaps, we could add a preprocessor
        symbol to enable a build which behaves like primer currently does, and the
        default build will be safe even in the face of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code>.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="build_configuration.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="../reference.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
