<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Exception Safety</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Lua Primer 0.0">
<link rel="up" href="../overview.html" title="Overview">
<link rel="prev" href="usage_and_configuration.html" title="Usage and Configuration">
<link rel="next" href="../reference.html" title="Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="usage_and_configuration.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="../reference.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="lua_primer.overview.exception_safety"></a><a class="link" href="exception_safety.html" title="Exception Safety">Exception Safety</a>
</h3></div></div></div>
<p>
        Primer is designed with the following constraints in mind:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Primer should work whether lua is compiled as C or C++.
          </li>
<li class="listitem">
            Primer should not require C++ exceptions or RTTI to be enabled.
          </li>
<li class="listitem">
            Primer should be safe -- error scenarios should not lead to crashes or
            undefined behavior.
          </li>
<li class="listitem">
            Primer should be fast -- similar in performance to if you skipped primer
            and coded using the C API directly.
          </li>
</ul></div>
<p>
        The main things that you must do to ensure good behavior are
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            When making a customization of <code class="computeroutput"><span class="identifier">push</span></code>,
            do not throw C++ exceptions. A lua error should only be raised in case
            of lua memory allocation failure.
          </li>
<li class="listitem">
            When making a customization of <code class="computeroutput"><span class="identifier">read</span></code>,
            do not throw C++ exceptions, or raise lua errors. If reading fails, return
            a <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">error</span></code>.
          </li>
<li class="listitem">
            Don't make lua callbacks (<code class="computeroutput"><span class="keyword">int</span><span class="special">(</span><span class="identifier">lua_State</span><span class="special">*)</span></code>) that throw. Those functions should
            handle problems internally or signal lua errors using the C api directly.
          </li>
<li class="listitem">
            Don't use PRIMER_ADAPT with functions <code class="computeroutput"><span class="identifier">primer_result</span><span class="special">(</span><span class="identifier">lua_State</span>
            <span class="special">*,</span> <span class="special">...)</span></code>
            that throw. These functions should return a <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">error</span></code>
            if they fail, which will cause primer to raise a corresponding lua error.
            These functions should only raise lua errors directly in case of lua
            memory allocation failure. If this really cramps your style, consider
            making a specialization of <code class="computeroutput"><span class="identifier">adapt</span></code>
            that catches some choice exceptions.
          </li>
</ul></div>
<h4>
<a name="lua_primer.overview.exception_safety.h0"></a>
        <span><a name="lua_primer.overview.exception_safety.design_considerations"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.design_considerations">Design
        Considerations</a>
      </h4>
<p>
        The two error scenarios that we consider here are:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            User code throws a <span class="emphasis"><em>C++ exception</em></span> to primer.
          </li>
<li class="listitem">
            Primer executes a lua operation which raises a <span class="emphasis"><em>lua error</em></span>.
          </li>
</ul></div>
<p>
        We take as a given that it is <span class="bold"><strong>not</strong></span> okay to
        throw foreign exceptions through lua, no matter how it is compiled. <sup>[<a name="lua_primer.overview.exception_safety.f0" href="#ftn.lua_primer.overview.exception_safety.f0" class="footnote">1</a>]</sup> <sup>[<a name="lua_primer.overview.exception_safety.f1" href="#ftn.lua_primer.overview.exception_safety.f1" class="footnote">2</a>]</sup> <sup>[<a name="lua_primer.overview.exception_safety.f2" href="#ftn.lua_primer.overview.exception_safety.f2" class="footnote">3</a>]</sup>
      </p>
<p>
        When a lua error occurs, what exactly happens is slightly different depending
        on whether lua is compiled as C or C++.
      </p>
<p>
        When lua is compiled as C++, lua API calls raise lua errors by throwing a
        C++ exception, which propagates back into lua and is caught there. In this
        case primer can use standard techniques to prevent problems.
      </p>
<p>
        When lua is compiled as C, the <code class="computeroutput"><span class="identifier">setjmp</span></code>
        and <code class="computeroutput"><span class="identifier">longjmp</span></code> functions are
        used to raise lua errors. The behavior is similar, but in this case, destructors
        of any C++ automatic objects are not called, and technically the standard
        says that undefined behavior results.
      </p>
<p>
        The primary reason to compile lua as C++ rather than as C is to avoid such
        issues. When using the raw lua C api to write callbacks, idiomatic C++ is
        not safe if <code class="computeroutput"><span class="identifier">longjmp</span></code> is called.
      </p>
<p>
        Fortunately, many lua C api calls don't raise lua errors, except in the case
        of a lua memory allocation failure. <sup>[<a name="lua_primer.overview.exception_safety.f3" href="#ftn.lua_primer.overview.exception_safety.f3" class="footnote">4</a>]</sup>
      </p>
<p>
        Most programs that use lua are not concerned with the possibility of a memory
        allocation failure, and are perfectly happy with a <code class="computeroutput"><span class="identifier">lua_panic</span></code>
        and program termination in such scenarios.
      </p>
<p>
        However, some programs are concerned with such things and Primer should be
        able to properly handle such errors. Moreover, we feel that it improves the
        overall reliability and maintainability of Primer if it is expected to be
        able to handle all possible errors, at least in some build configurations,
        and the build configurations which go faster by not handling memory allocation
        errors are created by explicitly disabling handling in select cases, rather
        than never having such handling at all.
      </p>
<h4>
<a name="lua_primer.overview.exception_safety.h1"></a>
        <span><a name="lua_primer.overview.exception_safety.goals"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.goals">Goals</a>
      </h4>
<p>
        To handle the tradeoff here, Primer responds to a special preprocessor define
        <code class="computeroutput"><span class="identifier">PRIMER_NO_MEMORY_FAILURE</span></code>.
      </p>
<p>
        When this symbol is defined, Primer will <span class="bold"><strong>assume</strong></span>
        that memory allocation failures will not occur, and use this assumption to
        <span class="bold"><strong>skip handling of such errors</strong></span> in order to
        run faster. Specifically:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Any lua C api function marked with <code class="computeroutput"><span class="identifier">m</span></code>
            in the manual (see <a href="http://www.lua.org/manual/5.3/manual.html#4.8" target="_top">4.8</a>)
            will not raise a lua error.
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> will not be thrown while
            pushing or reading any standard type or container (<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>,
            <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>).
          </li>
</ul></div>
<p>
        The rationale here is that lua is typically configured to use the same allocator
        as the rest of your program -- it's not that likely that lua is out of memory
        but the standard allocator is not, and there are few projects where the difference
        matters. <sup>[<a name="lua_primer.overview.exception_safety.f4" href="#ftn.lua_primer.overview.exception_safety.f4" class="footnote">5</a>]</sup>
      </p>
<p>
        This symbol is <span class="emphasis"><em>automatically defined</em></span> if lua is compiled
        as C. This decision allows Primer to be written in mostly idiomatic C++ code,
        because it means we can assume that lua memory allocation failures won't
        lead to <code class="computeroutput"><span class="identifier">longjmp</span></code>.
      </p>
<p>
        If memory allocation failures <span class="bold"><strong>do</strong></span> occur when
        this symbol is defined, <span class="emphasis"><em>undefined behavior will result</em></span>.
      </p>
<p>
        When lua is compiled as C++, and the symbol is not defined (the default),
        Primer will handle all such errors internally using <code class="computeroutput"><span class="keyword">try</span>
        <span class="special">/</span> <span class="keyword">catch</span></code>
        and <code class="computeroutput"><span class="identifier">lua_pcall</span></code>, without leaks
        or undefined behavior. Generally it will signal errors along normal channels
        to the user or to lua scripts in such cases.
      </p>
<h4>
<a name="lua_primer.overview.exception_safety.h2"></a>
        <span><a name="lua_primer.overview.exception_safety.handling_of_errors"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.handling_of_errors">Handling
        of Errors</a>
      </h4>
<p>
        Since Primer sits very close to lua and most of its functions could potentially
        be called by a lua callback, <span class="emphasis"><em>Primer doesn't throw any exceptions
        itself.</em></span>
      </p>
<p>
        Internally, Primer handles errors using a class template <code class="computeroutput"><span class="identifier">expected</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>,
        which is a discrminated union between a value and an error signal. When an
        operation was requested by the user and fails, usually we return this <code class="computeroutput"><span class="identifier">expected</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> type
        so that they get the error message by return value. When a callback created
        with primer fails after being called by lua, the error message is passed
        to lua and an error is raised.
      </p>
<p>
        Since we cannot throw exceptions through lua, or handle the user's exceptions,
        we sometimes have very few options in how to cope with them, and <span class="emphasis"><em>in
        many cases the user is not permitted to throw errors into Primer.</em></span>
      </p>
<p>
        Primer is mainly concerned with:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Basic exception safety:
            <div class="orderedlist"><ol class="orderedlist" type="a">
<li class="listitem">
                  Don't leak memory / objects. Don't put objects in an indeterminate
                  state.
                </li>
<li class="listitem">
                  Don't leak lua resources, e.g. fail to clean up objects on the
                  stack.
                </li>
</ol></div>
          </li>
<li class="listitem">
            Fail fast:
            <div class="orderedlist"><ol class="orderedlist" type="a">
<li class="listitem">
                  If an exception will reach lua, it is better to terminate the program.
                </li>
<li class="listitem">
                  If possible, use <code class="computeroutput"><span class="keyword">static_assert</span></code>
                  to enforce that exceptions will not be thrown by user code at places
                  where we aren't prepared to handle them.
                </li>
</ol></div>
          </li>
</ol></div>
<p>
        <sup>[<a name="lua_primer.overview.exception_safety.f5" href="#ftn.lua_primer.overview.exception_safety.f5" class="footnote">6</a>]</sup>
      </p>
<h5>
<a name="lua_primer.overview.exception_safety.h3"></a>
        <span><a name="lua_primer.overview.exception_safety.comments"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.comments">Comments</a>
      </h5>
<p>
        Note that this philosophy is different from how some C++ lua binding libraries
        work. Many of them have various ways of trying to handle the user's exceptions
        and either report them to lua as errors or try to get them across lua by
        various schemes without actually throwing them through lua.
      </p>
<p>
        <sup>[<a name="lua_primer.overview.exception_safety.f6" href="#ftn.lua_primer.overview.exception_safety.f6" class="footnote">7</a>]</sup> <sup>[<a name="lua_primer.overview.exception_safety.f7" href="#ftn.lua_primer.overview.exception_safety.f7" class="footnote">8</a>]</sup>
      </p>
<p>
        We consider that exceptions should only be used for very serious problems,
        and that if one is thrown, it is crucial that it reaches the handler you
        wrote in your program. Any of these mechanisms that blindly translate exceptions
        into lua errors can potentially lead to the exception being lost and swallowed
        if lua scripts are using <code class="computeroutput"><span class="identifier">pcall</span></code>
        to call your functions, and then it becomes very difficult to reason about
        what happens next. So we consider that catching user exceptions and trying
        to sneak them across the lua call boundary is not a very robust solution,
        and we don't plan to do something like this in Primer. We think it is a better
        idea to just terminate the program in such cases. If you want to create an
        exception-to-lua-error translation mechanism for use with Primer in your
        program you are welcome to specialize the <code class="computeroutput"><span class="identifier">adapt</span></code>
        class template in order to do it.
      </p>
<p>
        Instead, we are mainly concerned with avoiding leaks and indeterminate states,
        and preempting exceptions in places where we can't handle them.
      </p>
<h4>
<a name="lua_primer.overview.exception_safety.h4"></a>
        <span><a name="lua_primer.overview.exception_safety.exception_safety_requirements"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.exception_safety_requirements">Exception
        Safety Requirements</a>
      </h4>
<p>
        There are three ways that we will consider here that a user exception can
        reach Primer:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            A function which the user gave to <code class="computeroutput"><span class="identifier">PRIMER_ADAPT</span></code>,
            to push to lua, throws an exception.
          </li>
<li class="listitem">
            A user-defined object or container throws when we are manipulating it,
            e.g. when it is constructed, moved, or destroyed.
          </li>
<li class="listitem">
            A specialization of <code class="computeroutput"><span class="identifier">push</span></code>
            or <code class="computeroutput"><span class="identifier">read</span></code> throws an exception.
          </li>
</ol></div>
<p>
        Our handling of these situations is as follows:
      </p>
<h5>
<a name="lua_primer.overview.exception_safety.h5"></a>
        <span><a name="lua_primer.overview.exception_safety.a_user_function_which_was_adapte"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.a_user_function_which_was_adapte">A
        user function which was adapted for lua throws an exception</a>
      </h5>
<p>
        This should never happen, and we view it as a bug in user code if it does.
      </p>
<p>
        Essentially, we consider that if you used the lua C api directly to push
        such functions, you would get undefined behavior when they throw. To preempt
        this, we fail fast by marking one of the functions within the <code class="computeroutput"><span class="identifier">adapt</span></code> mechanism as <code class="computeroutput"><span class="keyword">noexcept</span></code>,
        which means that <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">terminate</span></code> will be called if your function
        throws when the adapted function is called.
      </p>
<h5>
<a name="lua_primer.overview.exception_safety.h6"></a>
        <span><a name="lua_primer.overview.exception_safety.a_userdata_object_throws_an_exce"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.a_userdata_object_throws_an_exce">A
        userdata object throws an exception</a>
      </h5>
<p>
        Userdata types are permitted to throw exceptions from their constructors.
        In such cases (<code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">push_udata</span></code>) Primer will abort and pop the
        uninitialized userdata object from the stack, and rethrow the exception.
        Primer does not ever call this function "automatically", you always
        call it explicitly in order to create userdata. So this exception always
        returns to the user and not into lua.
      </p>
<p>
        Userdata types must not throw exceptions from their destructors, if they
        are using the "default" garbage collection function. Even if they
        have custom <code class="computeroutput"><span class="identifier">__gc</span></code> metamethods,
        those metamethods must not throw exceptions. They aren't permitted to raise
        lua errors either, since lua gc happens as a continual process and those
        errors could appear at times that we aren't prepared to handle them.
      </p>
<h5>
<a name="lua_primer.overview.exception_safety.h7"></a>
        <span><a name="lua_primer.overview.exception_safety.an_object_which_primer_was_pushi"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.an_object_which_primer_was_pushi">An
        object which Primer was pushing or reading throws an exception from a special
        member function</a>
      </h5>
<p>
        Primer pushes C++ values by reference, and doesn't require making copies
        of them. So this actually isn't an issue with <code class="computeroutput"><span class="identifier">push</span></code>.
      </p>
<p>
        The container type <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">expected</span></code>
        imposes some constraints on objects that are <span class="emphasis"><em>read</em></span>.
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            Objects which will be held in <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">expected</span></code>
            must be <code class="computeroutput"><span class="identifier">nothrow_move_constructible</span></code>.
            That is, they cannot throw from their move constructor or destructor.
          </li></ul></div>
<p>
        For certain containers, that is, <span class="emphasis"><em>non-dynamic</em></span> containers
        like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">array</span></code> or structures registered using the
        <code class="computeroutput"><span class="identifier">VISIT_STRUCT</span></code> mechanism, additional
        requirements are placed on your objects when they are <span class="emphasis"><em>read</em></span>.
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            They must be <code class="computeroutput"><span class="identifier">nothrow_constructible</span></code>.
          </li>
<li class="listitem">
            They <span class="bold"><strong>should</strong></span> be <code class="computeroutput"><span class="identifier">nothrow_move_assignable</span></code>.
            If they are not, then Primer will attempt fallbacks:
            <div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem">
                  It will attempt an unqualified call to <code class="computeroutput"><span class="identifier">swap</span></code>
                  if it resolves to a <code class="computeroutput"><span class="keyword">noexcept</span></code>
                  function.
                </li>
<li class="listitem">
                  It will call the destructor explicitly and reconstruct using move-construction
                  with placement-new. This is usually less efficient than a move
                  assignment, so you should avoid this by providing a <code class="computeroutput"><span class="keyword">noexcept</span></code> move assignment operator
                  or a <code class="computeroutput"><span class="keyword">noexcept</span></code> specialization
                  of <code class="computeroutput"><span class="identifier">swap</span></code> in your
                  namespace.
                </li>
</ul></div>
          </li>
</ul></div>
<p>
        In general, the necessary preconditions are checked via <code class="computeroutput"><span class="keyword">static_assert</span></code>
        and your code won't compile if the assumptions aren't met.
      </p>
<p>
        For instance, <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">expected</span></code> is an exception-safe container
        in the strong sense. It's just that if the contained type is not <code class="computeroutput"><span class="identifier">nothrow_move_constructible</span></code> then you cannot
        compile.
      </p>
<h5>
<a name="lua_primer.overview.exception_safety.h8"></a>
        <span><a name="lua_primer.overview.exception_safety.a_specialization_of_push_or_read"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.a_specialization_of_push_or_read">A
        specialization of <code class="computeroutput"><span class="identifier">push</span></code> or
        <code class="computeroutput"><span class="identifier">read</span></code> throws an exception</a>
      </h5>
<p>
        Pushing an object is not permitted to fail. The only failure mode is that
        lua runs out of memory and raises a lua error.
      </p>
<p>
        Reading an object can fail, but it should return <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">error</span></code>
        in that case.
      </p>
<p>
        These functions are not supposed to throw exceptions under any circumstances,
        not even <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code>. It is considered a bug in user
        code if they do. The built-in implementations in primer all catch and internally
        handle <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bad_alloc</span></code> by returning a <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">error</span></code>. Push should not make C++ dynamic
        allocations, the C++ object that it is pushing already exists -- only lua
        is supposed to be making allocations there.
      </p>
<h5>
<a name="lua_primer.overview.exception_safety.h9"></a>
        <span><a name="lua_primer.overview.exception_safety.memory_allocation_failure"></a></span><a class="link" href="exception_safety.html#lua_primer.overview.exception_safety.memory_allocation_failure">Memory
        allocation failure</a>
      </h5>
<p>
        When compiled as C++, Primer handles memory allocation failures gracefully,
        and doesn't leak any C++ objects or memory. The only thing that Primer leaks
        in that scenario is lua stack objects -- if a lua memory error is raised
        within a primer call, then whatever it was doing at the time, it loses track
        of any temporary objects on the lua stack and they are forgotten about. In
        theory we could fix this by creating a series of RAII objects to protect
        every time we push such a temporary object onto the stack.
      </p>
<p>
        However, there is little purpose in this. In case of a callback or a pcall,
        lua unwinds the stack itself when it handles errors and will take care of
        all of these objects. In case of <code class="computeroutput"><span class="identifier">lua_resume</span></code>
        it does not unwind the stack, however, you will have to clear the thread
        stack after an error on resuming anyways -- primer discards the thread entirely
        in such cases.
      </p>
<p>
        So, all-in-all, programs written using Primer should be quite able to handle
        exceptional situations when lua is compiled as C++, and you should be able
        to successfully handle and recover from memory allocation errors without
        being forced to bring down your program.
      </p>
<p>
        If you don't care about recovering from memory allocation failures, then
        using lua compiled as C should be just fine. You just need to make sure to
        use callbacks of the form <code class="computeroutput"><span class="identifier">primer</span><span class="special">::</span><span class="identifier">result</span> <span class="special">(</span><span class="identifier">lua_State</span> <span class="special">*</span> <span class="special">,</span> <span class="special">...)</span></code>
        and not raise lua errors directly (to avoid leaks), or use the <code class="computeroutput"><span class="keyword">int</span><span class="special">(</span><span class="identifier">lua_State</span><span class="special">*)</span></code> form but very carefully.
      </p>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.lua_primer.overview.exception_safety.f0" href="#lua_primer.overview.exception_safety.f0" class="para">1</a>] </sup>
          c.f. <a href="http://lua-users.org/lists/lua-l/2007-10/msg00473.html" target="_top">lua
          mailing list</a>
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.lua_primer.overview.exception_safety.f1" href="#lua_primer.overview.exception_safety.f1" class="para">2</a>] </sup>
          c.f. <a href="http://lua-users.org/lists/lua-l/2010-03/msg00408.html" target="_top">more
          from lua mailing list</a>
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.lua_primer.overview.exception_safety.f2" href="#lua_primer.overview.exception_safety.f2" class="para">3</a>] </sup>
          c.f. <a href="http://lua-users.org/wiki/ErrorHandlingBetweenLuaAndCplusplus" target="_top">lua
          users wiki</a>
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.lua_primer.overview.exception_safety.f3" href="#lua_primer.overview.exception_safety.f3" class="para">4</a>] </sup>
          See <a href="http://www.lua.org/manual/5.3/manual.html#4.8" target="_top">4.8</a>
          in the lua manual. The notation <code class="computeroutput"><span class="special">[-</span><span class="identifier">o</span><span class="special">,</span> <span class="special">+</span><span class="identifier">p</span><span class="special">,</span> <span class="identifier">x</span><span class="special">]</span></code> is there explained: [: '-' means the function
          never raises any error; 'm' means the function may raise out-of-memory
          errors and errors running a <code class="computeroutput"><span class="identifier">__gc</span></code>
          metamethod]. For purposes of this discussion, we are going to ignore "errors
          running a <code class="computeroutput"><span class="identifier">__gc</span></code> metamethod".
          See also <a href="https://www.lua.org/pil/24.3.html" target="_top">here</a> and
          <a href="https://www.lua.org/pil/24.3.1.html" target="_top">here</a> in the manual.
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.lua_primer.overview.exception_safety.f4" href="#lua_primer.overview.exception_safety.f4" class="para">5</a>] </sup>
          Actually you can work around dependence on the standard allocator by specializing
          <code class="computeroutput"><span class="identifier">push</span></code> and <code class="computeroutput"><span class="identifier">read</span></code> for standard types <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>, <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>,
          etc.with custom allocators.
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.lua_primer.overview.exception_safety.f5" href="#lua_primer.overview.exception_safety.f5" class="para">6</a>] </sup>
          The applicability of <code class="computeroutput"><span class="keyword">static_assert</span></code>
          is unfortunately limited. For some simple things, it is helpful, but for
          callback functions, it is problematic. When lua is compiled as C, then
          a lua error is a <code class="computeroutput"><span class="identifier">longjmp</span></code>,
          so a function which throws no exceptions and may raise lua errors can be
          marked <code class="computeroutput"><span class="keyword">noexcept</span></code>. When lua
          is compiled as C++, lua errors are exceptions, so <code class="computeroutput"><span class="keyword">noexcept</span></code>
          cannot be used.
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.lua_primer.overview.exception_safety.f6" href="#lua_primer.overview.exception_safety.f6" class="para">7</a>] </sup>
          For instance, <code class="computeroutput"><span class="identifier">luabind</span></code> attempts
          to <span class="emphasis"><em>make lua exception-safe</em></span> in a limited sense -- they
          put a wrapper over all functions that you pass to lua through their interface,
          which catches <span class="emphasis"><em>all</em></span> exceptions derived from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">exception</span></code>, and raises a lua error to
          handle them, passing the <code class="computeroutput"><span class="identifier">e</span><span class="special">.</span><span class="identifier">what</span><span class="special">()</span></code> string to lua as the error message.
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.lua_primer.overview.exception_safety.f7" href="#lua_primer.overview.exception_safety.f7" class="para">8</a>] </sup>
          Another strategy that I've seen is to stash the exception object away in
          some static storage, pass on the signal to lua as a lua error, and rethrow
          the exception on the other side, once the error presumably propagates out
          to a <code class="computeroutput"><span class="identifier">pcall</span></code> somewhere.
        </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="usage_and_configuration.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="../reference.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
