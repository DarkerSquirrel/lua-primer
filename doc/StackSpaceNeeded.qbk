[section Stack Space Needed]

One aspect of lua that you may miss on your first pass through the manual is the
note about stack overflow.

lua's stack has only a limited size. In current versions of lua it is quite high,
e.g. more than ten thousand elements, but in past versions it may have only been 
a few hundred elements. With eris, it is somewhat smaller than in a default
configuration for various reasons. The stack space may also depend on the integer
sizes that lua is configured to use.

lua does not perform any bounds checking. When you push a string or an integer,
etc., if there is not enough space in the stack left, you get undefined
behavior.

This is of course to avoid the overhead of constant bounds checking. It is
expected that when you perform a "large" operation you might do some bounds
checking at the beginning, having an estimate of how much clearance you need.
The `lua_checkstack` function can tell you if there is enough space for a given
number of extra slots.

In `primer`, we support pushing complex containers in a single operation.
For that to be workable, we need to give you a way to figure out how much stack
clearance is needed to succeed.

We provide some `constexpr` functions that can do that for you.

[h3 `maybe_int`]

We provide a literal type called `maybe_int`.

You can think of `maybe_int` as a poor man's `constexpr optional<int>`, with semantics
such that the result of manipulating an unknown value is unknown.

The value is ['tested] using `operator bool`. If the `maybe_int` represents a known
value, the operator returns `true`. If the `maybe_int` represents an unknown value,
the operator returns `false`.

In case that there is a known value, it can be queried using `operator *`.

[primer_example_maybe_int]

`maybe_int` supports addition, subtraction, and multiplication, with `int` and
with other `maybe_int`. The result is always a `maybe_int`.

The `min` and `max` can be computed by `maybe_int::min` and `maybe_int::max`.

[h3 Querying stack space for an operation]

For convenience, we provide two functions which can estimate the stack space needed
for a read or push operation with a given type.

[primer_stack_space_for_read]
[primer_stack_space_for_push]

If the resulting `maybe_int` is vacant (`operator bool` returns false), it means that
no estimate was possible, for lack of information. This may happen if a user-defined
container or type doesn't provide an estimate, by accident, or because no
upper bound is possible for a given type without knowledge of its runtime value.

Currently we cannot provide an estimate for "visitable structures", although we
would like to fix that. For the other types and containers that are built-in to
primer, we do provide an accurate estimate.

Primer also uses these estimates interally. For instance, the `adapt` mechanism
will compute at compile-time a conservative estimate of how much space it needs to read the
arguments off of the stack, and call `lua_checkstack` before it begins. (`adapt`
also knows that it can skip the check unless the estimate exceeds `LUA_MINSTACK`.)

It also does such checks when calling a bound-function or coroutine.

It does not do any checks when you are just calling `primer::push` or `primer::read`.

If you don't define a `stack_space_needed` value for a custom specialization of `push` or `read`, then primer can't form an estimate
and will just skip the stack space checks.

[h4 Providing stack space estimates]

To provide a stack space estimate, when you specialize `push` or `read`, you
should provide a class member:

`static constexpr maybe_int stack_space_needed{4};`

if e.g. four additional stack spaces are needed to complete the operation.

[note When defining `primer::traits::push::stack_space_needed`, the value should
 be the smallest value `X` such that if `lua_checkstack(L, X)` returns true,
then the push operation will always succed without exausting the stack. This
value is always at least one -- `push` should always push something at the end,
even if it is just `nil`. It may be larger for complex objects like containers,
and may depend on the template parameters in that case.

If you don't define it, it is the same as defining it to "unknown".]

[note When defining `primer::traits::read::stack_space_needed`, the value should
 be the smallest value `X` such that if `lua_checkstack(L, X)` returns true,
then the read operation will always succeed without exhausting the stack. This
value is always at least zero. It may be larger for more complex objects.

If you don't define it, it is the same as defining it to "unknown".]

[endsect]
