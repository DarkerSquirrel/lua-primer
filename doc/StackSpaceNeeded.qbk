[section Stack Space Needed]

One aspect of lua that you may miss on your first pass through the manual is the
note about stack overflow.

lua's stack has only a limited size, and it doesn't perform bounds checking.
When you push a string or an integer,
etc., if there is not enough space in the stack left, you get undefined
behavior.

When you push things onto the stack, generically, you should use `lua_checkstack`,
which ensures that there is space for at least `n` more elements, or returns
`false` if allocation fails.

Instead of calling this constantly, usually you want to call it once at the
beginning of a "large-ish" operation.

In `primer`, we support pushing complex containers in a single operation.
For that to be workable, we need to give you a way to figure out how much stack
clearance is needed to succeed.

We provide some `constexpr` functions that can do that for you.

[h3 `maybe_int`]

We provide a literal type called `maybe_int`.

You can think of `maybe_int` as a poor man's `constexpr optional<int>`, with semantics
such that the result of manipulating an unknown value is unknown.

The value is ['tested] using `operator bool`. If the `maybe_int` represents a known
value, the operator returns `true`. If the `maybe_int` represents an unknown value,
the operator returns `false`.

In case that there is a known value, it can be queried using `operator *`.

[primer_example_maybe_int]

`maybe_int` supports `constexpr` addition, subtraction, and multiplication, with `int` and
with other `maybe_int`. The result is always a `maybe_int`.

The `min` and `max` can be computed by `maybe_int::min` and `maybe_int::max`.

[h3 Querying stack space for an operation]

For convenience, we provide two functions which can estimate the stack space needed
for a read or push operation with a given type.

[primer_stack_space_for_read]
[primer_stack_space_for_push]

If the resulting `maybe_int` is vacant (`operator bool` returns false), it means that
no estimate was possible, for lack of information. This may happen if a user-defined
container or type doesn't provide an estimate, by accident, or because no
upper bound is possible for a given type without knowledge of its runtime value.
(In that case the operation itself should perform a stack check.)

Currently we cannot provide an estimate for "visitable structures", although we
would like to fix that. For the other types and containers that are built-in to
primer, we do provide an accurate estimate.

Primer also uses these estimates interally. For instance, the `adapt` mechanism
will compute at compile-time a conservative estimate of how much space it needs to read the
arguments off of the stack, and call `lua_checkstack` before it begins. (`adapt`
also knows that it can skip the check unless the estimate exceeds `LUA_MINSTACK`.)

It also does such checks when calling a bound-function or coroutine.

It does not do any checks when you are just calling `primer::push` or `primer::read`.

If you don't define a `stack_space_needed` value for a custom specialization of
`push` or `read`, then primer can't form an estimate and will just skip the
stack space checks.

[h4 Providing stack space estimates]

To provide a stack space estimate, when you specialize `push` or `read`, you
should provide a class member `stack_space_needed` within the specialization:

``
namespace primer {
namespace traits {

template <>
struct push<foo> {
  static void to_stack(lua_State * L, const foo & f) { ... }
  static constexpr maybe_int stack_space_needed{4};
};

} // end namespace traits
} // end namespace primer

if e.g. four additional stack spaces are needed to complete the push operation.

[note When defining `stack_space_needed` for `primer::traits::push`, the value
should be the smallest value `X` such that if `lua_checkstack(L, X)` returns
`true`, then the push operation will always succed without exausting the stack.
This value is always at least one -- `push` should always push something at the
end, even if it is just `nil`. It may be larger for complex objects like
containers, and may depend on the template parameters in that case.

If you don't define it, it is the same as defining it to "unknown".]

[note When defining `stack_space_needed` for `primer::traits::read`, the value
should be the smallest value `X` such that if `lua_checkstack(L, X)` returns
`true`, then the read operation will always succeed without exhausting the
stack. This value is always at least zero. It may be larger for more complex
objects.

If you don't define it, it is the same as defining it to "unknown".]

[endsect]
