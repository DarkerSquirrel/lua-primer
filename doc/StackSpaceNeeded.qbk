[section Stack Space Needed]

One aspect of lua that you may miss on your first pass through the manual is the
note about stack overflow.

lua's stack has only a limited size. In current versions of lua it is quite high,
e.g. more than ten thousand elements, but in past versions it may have only been 
a few hundred elements. With eris, it is somewhat smaller than in a default
configuration for various reasons. The stack space may also depend on the integer
sizes that lua is configured to use.

lua does not perform any bounds checking. When you push a string or an integer,
etc., if there is not enough space in the stack left, you get undefined
behavior.

This is of course to avoid the overhead of constant bounds checking. It is
expected that when you perform a "large" operation you might do some bounds
checking at the beginning, having an estimate of how much clearance you need.
The `lua_checkstack` function can tell you if there is enough space for a given
number of extra slots.

In `primer`, we support pushing complex containers in a single operation.

For convenience, we provide two functions which can estimate the stack space needed:

[primer_stack_space_for_read]
[primer_stack_space_for_push]

These are `constexpr` template functions that tell you how much stack space is
needed for a `push` or `read` operation with a given type.

The value that they return is `primer::detail::maybe_int`.

You can think of this as a poor man's `constexpr optional<int>`, with semantics
such that the result of manipulating an unknown value is unknown.

[primer_example_maybe_int]

If the `maybe_int` is vacant (`operator bool` returns false), it means that
no estimate was possible, for lack of information. This may happen if a user-defined
container or type doesn't provide an estimate, by accident, or because no apriori
upper bound is possible for a given type.

The estimate can be accessed using `operator *`.

Currently we cannot provide an estimate for "visitable structures", although we
would like to fix that. For the other types and containers that are built-in to
primer, we do provide an accurate estimate.

Primer also uses these estimates interally. For instance, the `adapt` mechanism
will compute at compile-time a conservative estimate of how much space it needs to read the
arguments off of the stack, and call `lua_checkstack` before it begins.

It also does this when calling a bound-function or coroutine.

It does not do any checks when you are just calling `primer::push` or `primer::read`.

This adds some debuggability to your project - if your lua state is running out of slots or runs out of slots,
if one of the adapted functions is called it is likely to generate an error rather
than fail silently.

If you don't define a `stack_space_needed` value then primer can't form an estimate
and will just skip the stack space checks.

[h4 Providing stack space estimates]

To provide a stack space estimate, when you specialize `push` or `read`, you
should provide a class member:

`static constexpr detail::maybe_int stack_space_needed{4};`

if e.g. four additional stack spaces are needed to complete the operation.

[note When defining `primer::traits::push::stack_space_needed`, the value should
 be the smallest value `X` such that if `lua_checkstack(L, X)` returns true,
then the push operation will always succed without exausting the stack. This
value is always at least one -- `push` should always push something at the end,
even if it is just `nil`. It may be larger for complex objects like containers,
and may depend on the template parameters in that case.

If you don't define it, it is the same as defining it to "unknown".]

[note When defining `primer::traits::read::stack_space_needed`, the value should
 be the smallest value `X` such that if `lua_checkstack(L, X)` returns true,
then the read operation will always succeed without exhausting the stack. This
value is always at least zero. It may be larger for more complex objects.

If you don't define it, it is the same as defining it to "unknown".]

[endsect]
