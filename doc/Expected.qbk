[section Expected]

`primer::expected` is our primary error handling mechanism.

It is broadly similar in motivation, design, and implementation to the `std::expected`
type which was proposed for the C++17 standard.

It is a template class with the following signature:

``
  template <typename T>
  class expected;
``

This class is implemented as a discriminated union. It contains either a value
of type `T`, or a `primer::error`.

It is implicitly constructible from a value of type `T` or a `primer::error`.

If `T` is constructible from `U`, then `expected<T>` may be constructed from
`expected<U>`.

[h3 Accessors]

The state of the union is queried using `operator bool`, which returns true if
a value is present, and false if an error is present.

The value is accessed using `operator *`.
The error is accessed using member function `err()`.

These both give UB if the union is in the wrong state.

[h3 Specializations]

There are two important specializations of `expected`.

* `primer::expected<T&>` is specialized, since unions cannot contain references.
Instead, `primer::expected<T&>` is implemented as a wrapper over `expected<T*>`.
It is copyable and moveable, and can be reassigned like a pointer. However, when
it is dereferenced, it always returns `T&`, even if the `expected<T&>` is const.

* `primer::expected<void>` is specialized, so that it is essentially a `boost::optional<primer::error>`.
However, the semantics are such that it agrees with the other `expected` types. That is, `operator bool`
returns `false` when there is an error. `expected<void>` has no `operator *` and is not implicitly convertible
to or from any of the other expected types. It is default constructed in the "no error" state, unlike the others.
It is used to represent "operation proceeded successfully" or to report an error in carrying out some operation.

[endsect]
