[section push]

`primer::push` is a template function used to push a C++ value to the stack.

[primer_push]

* `push` is not permitted to fail -- any C++ value that currently can be pushed,
can be pushed without fail.

* `push` always pushes exactly one object onto the stack.

`primer::push_each` is an extension which pushes a sequence of objects.

``
  primer::push_each(L, a, b, c);
``

is equivalent to

``
  primer::push(L, a);
  primer::push(L, b);
  primer::push(L, c);
``

[/ primer_push_each]

[h3 Supported Types]

The following core types are supported:

[table
  [[Type] [`primer::push`]]
  [[`bool`]                [ Calls `lua_pushboolean`. ]]
  [[`int`]                 [ Calls `lua_pushinteger`. ]]
  [[`long`]                []]
  [[`long long`]           []]
  [[`unsigned int`]        [ Calls `lua_pushinteger`. ]]
  [[`unsigned long`]       []]
  [[`unsigned long long`]  []]
  [[`float`]               [ Calls `lua_pushnumber`. ]]
  [[`double`]              []]
  [[`long double`]         []]
  [[`const char *`]        [ Calls `lua_pushstring`. ]]
  [[`std::string`]         []]
]

[caution When pushing a signed integral type, integer overflow is not permitted to
      occur, and primer will not perform overflow checks.

      ['If a push operation
      requires a narrowing conversion of a signed integer type to `LUA_INTEGER`,
      a `static_assert` will fail and your code will not compile.]]

[caution When pushing a floating point type, primer will not check for overflow or
      loss of precision.

      ['If a push operation requires a narrowing conversion of a floating point
      type to `LUA_NUMBER`,
      a `static_assert` will fail and your code will not compile.]]

[note When pushing an unsigned integral type which is larger than `LUA_INTEGER`,
      primer will implicitly narrow it to the unsigned version of `LUA_INTEGER`,
      then perform a portable conversion from that type to `LUA_INTEGER`.

      This behavior is well-defined by the standard, but for your code to be
      portable in the sense of giving similar results on different machines where
      lua may be configured to use 32-bit or 64-bit integers,
      you must avoid such narrowing conversions.]

[note For maximum portability, consider:

      - Only pushing 32 bit types, e.g., `int`, `unsigned int`, `float` on most
        platforms.

      - Using `LUA_INTEGER` and the unsigned version of that in your code, and
        only push these.

      If you just want to compile and don't care about overflow, you can do so
      with expressions like

      ``
        long long i;
        primer::push(L, static_cast<LUA_INTEGER>(i));
      ``

      Or, install custom handling for integer types like `long` and `long long`, see below.
      ]


The following ancillary types are supported (see `primer::read` docs for more info).

[table
  [[Type] [`primer::push`]]
  [[`primer::nil_t`]   [ Calls `lua_pushnil`. ]]
  [[`primer::truthy`]  [ Calls `lua_pushboolean`. ]]
  [[`primer::stringy`] [ Calls `lua_pushstring`. ]]
]


Primer includes additional headers to support some C++ standard containers and
and boost containers, which are pushed as tables. See the containers section for
details.

* `std::vector`
* `std::array`
* `std::set`
* `std::map`
* `std::unordered_map`
* `boost::flat_set`

[h3 Customization]

The trait `primer::traits::push` can be specialized to override primer's behavior
for certain types, or to add new behavior for custom types.

[primer_example_vec2i_defn]
[primer_example_vec2i_push_trait]
[primer_example_vec2i_push_test]

[endsect]
