[section userdata]

Primer can be told to recognize any C++ type as a *userdata* type. This means
that you can construct it within lua.

Primer recognizes userdata types using a trait, `primer::traits::userdata`.
This trait must be specialized for any type which primer will recognize as userdata.

The trait can / should provide three things:

* A name for the userdata type (used as a key in lua, and in error messages)
* A list of functions to go in the metatable
* A list of functions to go in the permanent objects table.

Given this information, primer is able to create the metatable of this userdata
type on demand, and store the necessary functions in the permanent objects table
so that this userdata can be serialized.

In a pure-lua (no eris) application, not all of these are necessary. The permanent
objects table could be skipped. Even the metatable functions could be skipped --
you could recover the metatable yourself using `luaL_getmetatable` and the key,
and adjust it as you like. If there is no userdata name, though, then primer is
not able to ['read] this userdata type using `primer::read`, so there is little
that we can do with it.

[h4 Representing lists of functions]

It is quite common in lua C API programming to need to be able create lists of
functions paired with their names. lua has a standard idiom for this.
The following structure is defined
in the lua headers:

``
  struct luaL_Reg {
    const char * name;
    lua_CFunction func;
  };
``

Many lua functions take as a parameter a pointer `const luaL_Reg *`, which is
expected to point into an array, terminated by a `luaL_Reg` holding two null pointers.
(See [@http://www.lua.org/manual/5.2/manual.html#luaL_Reg the manual].)

In primer, we respect this idiom, but we extend it as follows:

* Null-terminated array is supported
* Any standard container (`std::array`, `std::initializer_list`, `std::vector`) is supported, with or without null terminators.
* The type need not actually be `luaL_Reg` -- as long as it has public members `const char * name`
and `lua_CFunction func` then that is sufficient.

In total we call this concept "`L_Reg_sequence`".


[h4 Pushing userdata]

`primer::push_udata` is a template function which is used to construct new userdata objects on the stack.

`push_udata` expects the userdata type as an explicit template parameter, and forwards all arguments to the constructor.

```
  template <typename T, typename... Args>
  void push_udata(lua_State * L, Args && ... args);
```

It is best if your constructor is `noexcept`, but this is not always possible. If it is not noexcept, then in the 
event of an exception thrown from the constructor, primer will pop the userdata entry from the stack, and rethrow the exception.

[h4 Reading userdata]

While primitive types like `number`, `string`, and `table` are generally read from the lua stack by value, as C++ primitives or containers, for userdata types this is usually much less useful.

Instead, userdata types are generally read from the stack *by reference*.

TODO

[h4 Adapting userdata methods]

`PRIMER_ADAPT_USERDATA` is an extension of `PRIMER_ADAPT` which handles member functions of a userdata type.

Functions thus adapted expect to be called using the standard `object:method(arg1, arg2)` syntax in lua, meaning that
the base `object` is actually the first element on the stack.

This is convenient because sometimes its a little nicer to implement userdata methods as C++ methods rather than free
functions. `PRIMER_ADAPT` can only directly handle free functions.

[h4 Userdata trait requirements]

A specialization of the `userdata` trait *must* provide the following members:

* `static const char * name`: A name associated to the userdata. The metatable will be constructed using `luaL_newmetatable`,
  using this name as the key. This name may also be displayed in certain error messages, e.g. if userdata of this type was expected and not found.

It *may* provide the following additional members:

* `static L_Reg_sequence metatable`: A null-terminated list of methods for this userdata. This must include a `__persist` method, or the
  userdata cannot be persisted correctly. See eris' documentation.

* `static L_Reg_sequence permanents`: A null-terminated list of other functions related to this userdata which must be listed in the permanent
  objects table. Commonly this list contains constructors or other functions related to the type and exposed to the user or via the `__persist` metamethod.

If the `metatable` entry is missing, primer will install a minimalistic metatable for your type.

If the `metatable` entry is present, but no `__gc` method is present, primer will generate one which calls the destructor for your type.
This is almost always what you want, except for debugging purposes, or if your type is trivial and does not need a destructor call.
In that case, you block primer from installing `__gc` by putting `{"__gc", nullptr}` in the list -- primer will not register a null pointer
as a C function.

If the `metatable` entry is present, and no `__index` method is present, primer will implement a common idiom in which the metatable itself
is set to be its own index table. Again, you can block this by registering any function for `__index`.

The `permanents` list is similar to the `metatable` list, except that those objects will become part of the ['permanent objects table] when
persisting and unpersisting a state that has this userdata. See the "API" section for more info.

[h4 Alternative syntax]

If setting up your metatable is too complex to use the above pattern, for example, if you have entries that need to be set to tables, 
or you also must add things to the registry to support your type, or something like this, then you can use an alternate method:

* `static void metatable(lua_State *)`

In this case you can manually control the population of the metatable. Primer will call `luaL_newmetatable` using the name first, and your function
will be called with the new metatable on top of the stack. Your function is supposed to add members to it and do any other appropriate setup, and return
with the stack in the same position that it was found.

Your function will only be called once, when the metatable is initialized, for any given lua State.


[endsect]
