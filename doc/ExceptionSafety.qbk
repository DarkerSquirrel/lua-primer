[section Exception Safety]

Primer is designed with the following constraints in mind:

* Primer should work whether lua is compiled as C or C++.
* Primer should not require C++ exceptions or RTTI to be enabled.

We also take as a given that it is *not* okay to throw foreign exceptions
through lua, no matter how it is compiled.

* c.f. [@http://lua-users.org/lists/lua-l/2007-10/msg00473.html lua mailing list]
* c.f. [@http://lua-users.org/wiki/ErrorHandlingBetweenLuaAndCplusplus lua users wiki]
* c.f. [@http://stackoverflow.com/questions/4615890/how-to-handle-c-exceptions-when-calling-functions-from-lua stackoverflow]

So, we don't throw any exceptions ourselves, and since many components of
Primer are designed to be called by functions that will be passed to lua as function
pointers, it's not a very good idea for them to be throwing exceptions either.

Internally, Primer handles errors using a class template `expected<T>`, which
is a discrminated union between a value and an error signal. It makes the most sense
to return such objects to the user as well. Several functions
that could be called by the user and could fail return this type. Essentially,
we do that where some other libraries might throw exceptions.

Since we cannot throw exceptions through lua,
or handle the user's exceptions, we sometimes have very few options here. Primer is mainly concerned with:

# Basic exception safety:
  # Don't leak memory / objects. Don't put objects in an indeterminate state.
  # Don't leak lua resources, such as stack positions or lua's memory.
# Fail fast:
  # If an exception will reach lua, it is better to terminate the program.
  # If possible, use `static_assert` to enforce that exceptions will not be thrown
    by user code at places where we aren't prepared to handle them.

Note that this philosophy is different from how some lua-binding libraries work.
For instance, `luabind` attempts to ['make lua exception-safe] in a limited
sense -- they put a wrapper over all functions that you pass to lua through
their interface, which catches ['all] exceptions derived from `std::exception`,
and raises a lua error to handle them, passing the `e.what()` string to lua as
the error message.

Another strategy that I've seen is to stash the exception object away in some
static storage, pass on the signal to lua as a lua error, and rethrow the
exception on the other side, once the error presumably propagates out to a
`pcall` somewhere.

We consider that exceptions should only be used for very serious problems, and
that if one is thrown, it is crucial that it reaches the handler you wrote in
your program. Any of these mechanisms that translate exceptions into lua errors
can potentially lead to the exception being lost and swallowed if lua scripts
are using `pcall` to call your functions, and then it becomes very difficult to
reason about what happens next. So we consider that catching user exceptions
and trying to sneak them across the lua call boundary is not a very robust
solution, and we don't plan to do something like this in Primer. We consider
that it is usually a better idea to just terminate the program in such cases.
If you want to create an exception-to-lua-error translation mechanism for use
with Primer in your program you are welcome to specialize the `adapt` class
template in order to do it.

Instead, we are mainly concerned with avoiding leaks and indeterminate states,
and preempting exceptions in places where we can't handle them.

There are three (main) ways that an exception can reach Primer:

# A function which the user gave to `PRIMER_ADAPT`, to push to lua, throws an
  exception.
# A user-defined object or container throws when we are manipulating it, e.g.
  when it is constructed, moved, or destroyed.
# A specialization of `push` or `read` throws an exception.

The situations that we have a handle on are:

[h4 A user function which was adapted for lua throws an exception]
 
This should never happen, and we view it as a bug in user code if it does.

Essentially, we consider that if you used the lua C api directly to push such
functions, you would get undefined behavior when they throw. To preempt this,
we fail fast by marking one of the functions within the `adapt` mechanism as
`noexcept`, which means that `std::terminate` will be called if your function
throws when the adapted function is called.

It would be better if we could fail faster -- make a `static_assert` that any
function passed to `adapt` is `noexcept`. However, in the C++11 standard this is
difficult because `noexcept` is not properly part of a function pointer's type.
(In C++17 that will change, supposedly.) There are some other complications with
that idea when lua is compiled as C++. So, it's just a runtime error.

[h4 An object which Primer was handling throws an exception]

The first case is userdata types.

* Userdata types are permitted to throw exceptions from their constructors.
  In such cases (`primer::push_udata`) Primer will abort the creation of the
  userdata object and free the memory associated to it, and rethrow the exception.
  Primer does not ever call this function "automatically", you always call
  it explicitly in order to create userdata. So the exceptions are your problem. :)
* Userdata types must not throw exceptions from their destructors, if they are
  using the "default" garbage collection function. `std::terminate` will be called.

(Hypothetically you could implement your own garbage collection function, but
it still wouldn't be able to throw exceptions, as they would emerge right into
lua.)

More generally, Primer sometimes handles objects for which you may have specialized
`push` or `read`. These objects must satisfy some requirements.

* Objects which will be held in `primer::expected` must be `nothrow_move_constructible`.
  That is, they cannot throw from their move constructor or destructor.

For certain containers, that is, ['non-dynamic] containers like `std::array` or
structures registered using the `VISIT_STRUCT` mechanism, additional requirements
are placed on your objects.

* They must be `nothrow_constructible`.
* They *should* be `nothrow_move_assignable`. If they are not, then Primer will attempt fallbacks:
  * It will attempt an unqualified call to `swap` if it resolves to a `noexcept` function.
  * It will call the destructor explicitly and reconstruct using move-construction with
    placement-new. This is usually less efficient than a move assignment, so you should
    avoid this by providing a `noexcept` move assignment operator or a `noexcept` specialization
    of `swap` in your namespace or in the `std` namespace.

In general, the necessary preconditions are checked via `static_assert` and your code won't compile if the assumptions aren't met.

For instance, `primer::expected` is an exception-safe container in the strong sense.
It's just that if the contained type is not `nothrow_move_constructible` then you cannot compile.

[h4 A specialization of `push` or `read` throws an exception]

Currently, we assume that pushing an object cannot fail.

Reading an object can fail, but it should return `primer::error` in that case.

These functions are not supposed to throw exceptions, and currently it is considered a bug if they do.

There is no mechanism in place right now to make a `static_assert` that they are `noexcept`.
That is something that we might try to add in the future, but it's tricky for various reasons.

[h4 Memory allocation failure]

The only exceptions that Primer actually does attempt to catch and handle internally
are `std::bad_alloc` exceptions caused when allocations for `std::string`, `std::vector`,
etc. fails. These can occur during calls to `primer::read`.

Our strategy to is to clean up after ourselves and return a `primer::error` with the
message `"bad_alloc"`. (There are some fallbacks in case this string itself cannot
be allocated... see `primer::error` implementation.)

From lua's point of view, what this means is that if a script calls a callback function
and `std::bad_alloc` occurs while reading its parameters, a lua error `"bad_alloc"` will
result.

In standard configurations, lua will actually be using the same allocator as the overall
program, which means that lua is itself likely to generate a memory error very soon.

However, in general we take the view that `std::bad_alloc` in a lua callback function
is potentially recoverable. If the script can run to completion even in the face of
certain calls failing with errors, and the lua VM itself doesn't raise a memory error,
then we consider this a successful outcome, and
similar to how lua may works more generally when you call lua functions using `pcall`
and allocation failures occur.

When reading your custom containers off of the lua stack, you should likely pursue a similar strategy.

['It is not safe to throw `std::bad_alloc` out of a specialization of `primer::traits::read`, this
can and will result in the program being terminated.]

Memory allocation failures can also occur when *pushing* things to lua, if the lua allocator
cannot perform an allocation. This scenario is somewhat more complex.

When the lua allocator runs out of memory, almost any API function can trigger the fault.
For instance, `lua_pushstring` can fail, only in the scenario that lua cannot allocate enough memory.
This could potentially cause a `longjmp` and the leaking of objects on the C++ stack.
Almost all api calls are error-free, except in the case of lack of memory, but actually very few are
error-free in the face of an allocation failure.

See especially [@https://www.lua.org/pil/24.3.html here] and [@https://www.lua.org/pil/24.3.1.html here] in the manual.

When such api calls do fail, lua immediately raises a lua error. If the call is not a "protected" call, then
`lua_panic` occurs and the program is terminated.

Even if the call is a protected call, bad things happen from the point of view of C++ functions. If lua
is compiled as C, then it will perform a `longjmp` across your stack and back into itself, skipping any `catch` that you may have set,
and tossing any automatic objects on the stack without calling their destructors. Technically this is UB.
From Primer's point of view, the only way we could avoid leaks in this scenario is if nearly every API call were made
in its own protected context, which would significantly impact performance.

If you compile as C++ the situation is significantly better. In this case, lua signals errors to itself using C++ exceptions
rather than `setjmp` and `longjmp`. This means that stack objects are not leaked and UB does not occur. In this scenario,
Primer leaks no C++ objects and no containers are left in indeterminate states.

The only thing that Primer leaks in that scenario is lua stack objects -- whatever it was doing at the time,
it loses track of any temporary objects on the lua stack and they are forgotten about. In theory we could fix this by
creating a series of RAII objects to protect against exceptions every time we push such an object onto the stack.

However, there is little purpose in this. The only scenario in which these errors are raised in the first place is when
lua itself is running out of memory, and the fault is triggered in a callback which was run by your script. In that case you can simply
toss the lua stack with `lua_settop(L, 0)` and any leaked stack objects are taken care of. Likely you are going to close
the state anyways, but even if you don't, at that point you are good to go -- no C++ or lua resources are leaked.

So, all-in-all, programs written using Primer should be quite able to handle exceptional situations when lua is compiled as C++,
and you should be able to successfully handle and recover from memory allocation errors without being forced to bring down your program.

If you don't particularly care about recovering from memory allocation failures, then using lua compiled as C should be just fine.

The main things that you must do to ensure good behavior are
* Don't make specializations of `push` or `read` that throw exceptions. In case of `read`, return an error.
* Don't make lua callbacks that throw. Those functions should be `noexcept` and handle problems internally
or signal lua errors. If this really cramps your style, consider making a specialization of `adapt` that catches
some choice exceptions and handles them appropriately.
* If lua reports an out of memory error, remember to toss the stack if you attempt to recover.

[endsect]
