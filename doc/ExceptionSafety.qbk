[section Exception Safety]

Primer is designed with the following constraints in mind:

* Primer should work whether lua is compiled as C or C++.
* Primer should not require C++ exceptions or RTTI to be enabled.

We also take as a given that it is *not* okay to throw foreign exceptions
through lua, no matter how it is compiled.

* c.f. [@http://lua-users.org/lists/lua-l/2007-10/msg00473.html lua mailing list]
* c.f. [@http://lua-users.org/wiki/ErrorHandlingBetweenLuaAndCplusplus lua users wiki]
* c.f. [@http://stackoverflow.com/questions/4615890/how-to-handle-c-exceptions-when-calling-functions-from-lua stackoverflow]

So, we don't throw any exceptions ourselves, and since many components of
Primer are designed to be called by functions that will be passed to lua as function
pointers, it's not a very good idea for them to be throwing exceptions either.

Internally, primer handles errors using a class template `expected<T>`, which
is a discrminated union between a value and an error signal. It makes the most sense
to return such objects to the user as well. Several functions
that could be called by the user and could fail return this type. Essentially,
we do that where some other libraries might throw exceptions.

Since we cannot throw exceptions through lua,
or handle the user's exceptions, we sometimes have very few options here. Primer is mainly concerned with:

# Basic exception safety:
  # Don't leak memory / objects. Don't put objects in an indeterminate state.
  # Don't leak lua resources, such as stack positions or lua's memory.
# Fail fast:
  # If an exception will reach lua, it is better to terminate the program.
  # If possible, use `static_assert` to enforce that exceptions will not be thrown
    by user code at places where we aren't prepared to handle them.

Note that this philosophy is different from how some lua-binding libraries work.
For instance `luabind` attempts to ['make] lua exception safe in a limited
sense -- they put a wrapper over all functions that you pass to lua through
their interface, which catches ['all] exceptions derived from `std::exception`,
and raises a lua error, passing the `e.what()` string to lua as error message.
Another strategy that I've seen is to stash the exception object away in some
static storage, pass on the signal to lua as a lua error, and rethrow the
exception on the other side, once the error presumably propagates out to a
`pcall` somewhere.

We consider that exceptions should only be used for very serious problems, and
that if one is thrown, it is crucial that it reaches the handler you wrote in
your program. Any of these mechanisms that translate exceptions into lua errors
can potentially lead to the exception being lost and swallowed if lua scripts
are using `pcall` to call your functions, and then it becomes very difficult to
reason about what happens next. So we consider that catching user exceptions
and trying to sneak them across the lua call boundary is not a very robust
solution, and we don't plan to do something like this in primer. We consider
that it is usually a better idea to just terminate the program in cases like
this. If you want to create some exception-to-lua-error mechanism like this,
you are welcome to specialize the `adapt` class template in order to do it.

Instead, we are mainly concerned with avoiding leaks and indeterminate states,
and preempting exceptions in places where we can't handle them.

There are three (main) ways that an exception can reach primer:

# A function which the user gave to `PRIMER_ADAPT`, to push to lua, throws an
  exception.
# A user-defined object or container throws when we are manipulating it, e.g.
  when it is constructed, moved, or destroyed.
# A specialization of `push` or `read` throws an exception.

The situations that we have a handle on are:

[h4 A user function which was adapted for lua throws an exception]
 
This should never happen, and we view it as a bug in user code if it does.

Essentially, we consider that if you used the lua C api directly to push such
functions, you would get undefined behavior when they throw. To preempt this,
we fail fast by marking one of the functions within the `adapt` mechanism as
`noexcept`, which means that `std::terminate` will be called if your function
throws when the adapted function is called.

[h4 An object which primer was handling throws an exception]

* Userdata types are permitted to throw exceptions from their constructors.
  In such cases (`primer::push_udata`) primer will abort the creation of the
  userdata object and free the memory associated to it, and rethrow the exception.
* Userdata types must not throw exceptions from their destructors.
  `std::terminate` will be called.

More generally, primer sometimes handles objects for which you may have specialized
`push` or `read`. These objects must satisfy some requirements.

* Objects which will be held in `primer::expected` must be `nothrow_move_constructible`.
  That is, they cannot throw from their move constructor or destructor.

For certain containers, that is, ['non-dynamic] containers like `std::array` or
structures registered using the `VISIT_STRUCT` mechanism, additional requirements
are placed on your objects.

* They must be `nothrow_constructible`.
* They *should* be `nothrow_move_assignable`. If they are not then primer will attempt fallbacks:
  * It will attempt an unqualified call to `swap` if it resolves to a `noexcept` function.
  * It will call the destructor explicitly and reconstruct using move-construction with
    placement-new. This is usually less efficient than a move assignment, so you should
    avoid this by providing `noexcept` move assignment operator or a `noexcept` specialization
    of `swap` in your namespace or in the `std` namespace.
    
In general, the necessary preconditions are checked via `static_assert` and your code won't compile if the assumptions aren't met.

For instance, `primer::expected` is an exception-safe container in the strong sense. It's just that if your type is not `nothrow_move_constructible` then you cannot compile.

[h4 A specialization of `push` or `read` throws an exception]

Currently, we assume that pushing an object cannot fail.

Reading an object can fail, but it should return `primer::error` in that case.

These functions are not supposed to throw exceptions, and currently it is considered a bug if they do.

There is no mechanism in place right now to make a `static_assert` that they are `noexcept`.
That is something that we might add in the future.

That being said...

[h4 Memory allocation failure]

There are a few known situations in primer that we do things within a `primer::read` specialization
that can cause `std::bad_alloc` to be thrown, and don't have proper handling for it. For instance, when constructing a `std::string` from
a C-string obtained from lua, or when calling `emplace_back` on a `std::vector`. 

The consequences of this can currently include:

* Primer losing track of objects that it pushed onto the lua stack. If this happens repeatedly, you can run out of space on the lua stack and get a lua panic.
* An exception being thrown into the `adapt` mechanism, causing the program to be terminated.

Similarly, we don't currently handle properly some errors that can occur when ['lua] runs out of memory.
For instance, `lua_pushstring` can fail, only in the scenario that lua cannot allocate enough memory.
This could potentially cause a `longjmp` and the leaking of objects on the C++ stack.

See especially [@https://www.lua.org/pil/24.3.html here] and [@https://www.lua.org/pil/24.3.1.html here] in the manual.

In the majority of projects that use the lua C api, the overhead of running essentially all C api calls in protected
mode is not worth the benefits. Especially in the case of game projects, a `lua_panic` in the face of an out of memory
error is acceptable -- the developers are likely to install a custom memory allocator anyways, and they may periodically
check it to see if they are "close" to running out of memory and preempt the situation that way. Then in the rest of the
code, they run faster since they basically assume that allocation always succeeds.

I believe that for purposes of such projects, primer is essentially working correctly right now in
regards to exception safety. That is, we *are* correct in the face of exceptions, if we are permitted to exclude the
scenarios in which the lua or C++ allocator runs out of memory.

As a long-term goal, we would like to be able to provide correctness even in the face of out-of-memory errors. Perhaps,
we could add a preprocessor symbol so that primer will attempt to handle `std::bad_alloc` exceptions, and will run C api
calls in a protected mode so that if lua runs out of memory, we can avoid a panic. However, currently that is not what
we do.

There is an experimental branch `primer_handle_bad_alloc` which contains some partial progress towards this.

[endsect]
