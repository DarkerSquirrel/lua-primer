[section lua_ref]

A `primer::lua_ref` is a reference to a lua value which exists in a lua VM.

It is a "weak pointer", in the sense that, obtaining the value from the reference may fail,
if for instance, the VM has already been destroyed.

Despite it's name, `lua_ref` does not have the semantics of a C++ reference. It has
an empty state, and can be assigned and reassigned to point to different objects.

[h2 Usage]

To bind a `lua_ref` to a lua value,

# Push the value onto the top of the stack.
# Construct a `lua_ref` from the pointer `lua_State *` for that stack.
This pops the object from the stack.

If the stack is empty, then the `lua_ref` is placed in the empty state.

It can be default constructed in the empty state as well.

If the lua VM is destroyed (closed), the `lua_ref` reverts to the empty
state the next time an attempt is made to access it.

While the VM is not closed, the referred object will not be garbage
collected by lua.

The value can be obtained from the reference by using the `push` methods, or the `as` method.

[primer_example_ref]

[h2 Header]

[primer_lua_ref]

[note While `primer::lua_ref` is copyable, copying it is not that cheap as it has
 has to lock the VM, push the object, and create a new ref. ]

[h2 Safety and ownership]

`primer::lua_ref` is safe in the sense that it will fail to lock
in that case, rather than giving undefined behavior.

However, `primer::lua_ref` cannot take ownership of a lua VM, nor
is it thread-safe.

[caution You must not pass these objects across threads. Lua is generally not thread safe anyways, so this
should come as no surprise. ]

As long as the lua state is alive, it will not garbage collect an object referred to by `primer::lua_ref`.

This is achieved using the `luaL_ref` mechanism, see lua docs.

[h2 Read / Push semantics]

Using `primer::push` with a `primer::lua_ref` calls the thread-push member function,
and so comes with all the caveats above.

Using `primer::read` with a `primer::lua_ref` *always* succeeds in binding to a value
at the given position, unless it is nil or out of bounds, in which case it produces
a `lua_ref` in the empty state.

This makes it effectively an "any" type for purposes of function parameters,
and you can use "as" to easily try to interpret it as other values later. So it
can be used sort of as a poor man's variant.

Here's an example function to illustrate:

[primer_example_ref_read_func]

And example semantics:

[primer_example_ref_read_test]

Note that, it is not too difficult to implement your own `read` and `push`
specializations for a proper variant type that appears in your program -- but
generating a good *generic* `primer::traits::read` template for e.g. `boost::variant` seems quite difficult, and
so we don't do it right now.

[endsect]
