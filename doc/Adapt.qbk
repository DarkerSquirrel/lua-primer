[section adapt]

`PRIMER_ADAPT` refers to the mechanism that implements type-safe parameter reading for user functions.

The core object is a template

[primer_adaptor_decl]

When given a function pointer `f`, `adaptor` is expected to provide a static member function of signature
`int (lua_State *)` which is named `adapted`.

Given a function pointer of the form,

``
  primer::result my_func(lua_State * L, std::string foo, bool bar, int baz);
``

the adaptor converts it to a function somewhat similar to the following:

``
  primer::result my_func_helper(lua_State * L) {
    auto arg1 = primer::read<std::string>(L, 1);
    if (!arg1) { return arg1.err(); }

    auto arg2 = primer::read<bool>(L, 2);
    if (!arg2) { return arg2.err(); }

    auto arg3 = primer::read<int>(L, 3);
    if (!arg3) { return arg3.err(); }

    return my_func(L, *arg1, *arg2, *arg3);
  }

  int my_func_adapted(lua_State * L) {
    if (auto r = my_func_helper(L)) {
      if (r->is_return_) {
        return r->n_;
      } else {
        return lua_yield(L, r->n_);
      }
    } else {
      lua_pushstring(L, r.err_str().c_str());
      return lua_error(L);
    }
  }
``

Each parameter is read from the stack in succession using `primer::read`. If any cannot
be read, then the input is invalid and an error is returned. If all can be read, then
the user function is invoked, and its result returned.

`primer::result` is implemented by a simple return in the case of a return,
by calling `lua_yield` in case of a yield, and by signaling a lua error in case of
an error. This part is quite trivial -- the only subtlety in the actual implementation
involves making sure that it works with no leaks, whether lua is compiled as C or C++.

[caution When using the adapt mechanism, if lua is compiled as C, the user function
      `my_func` must not trigger a lua error directly -- it must return objects of the
      form `primer::error` instead.

      If it does not, then a lua error triggers a call
      to `longjmp` which will toss any automatic objects on the stack without calling
      destructors. This will leak all of the input parameters, and technically causes
      undefined behavior according to the C++ standard. 

      A similar statement holds for calling `lua_yield(L, n)`. You should instead return
      `primer::yield(n)`.]

The `PRIMER_ADAPT` macro is defined:
[primer_adapt]

so that `PRIMER_ADAPT` can be used to push complex functions directly to lua, e.g.:

```
  lua_pushcfunction(L, PRIMER_ADAPT(&my_func));
```

`primer::adaptor` also has a trivial specialization for functions which are already `lua_CFunction`:

[primer_adaptor_trivial]

[h2 Customization]

If you would like to implement a custom parameter reading / error handling mechanism, you can do that by introducing
a new return type for such functions, and specializing the `adaptor` class template for function pointers with your
given return type.

Your functions using the new return type would then be automatically recognized also by `PRIMER_ADAPT_USERDATA`
and `USE_LUA_CALLBACK` in an `api::base` object.

[endsect]
