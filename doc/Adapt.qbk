[section Adapt]

`PRIMER_ADAPT` is the basic dispatch mechanism that implements type-safe parameter reading and error handling.

Given a function pointer e.g.

```
  primer::result my_func(lua_State * L, std::string s, int x, int y);
```

it can be pushed directly to lua using

```
  lua_pushcfunction(L, PRIMER_ADAPT(&my_func));
```

That is, the type of `PRIMER_ADAPT(&my_func)` is `lua_CFunction, i.e. int (*)(lua_State*)`.

  

The core object is a template

`template <typename F, F f> struct adaptor;`

which, given a function pointer `f`, is expected to provide a static member function of signature
`int (lua_State *)` which is named `adapted`.

The adaptor is wraps a given function pointer with some boilerplate which when invoked, will attempt to read
values off of the lua stack which match the function signature, using `primer::read`. In case this fails, it
immediately reports an error to lua code with the argument index and expected type. If it succeeds, it passes
the arguments to `f`.

By default, the adaptor expects the function pointers that it is given to return a `primer::result`. The given
function is supposed to push whatever return values onto the stack, if it plans to return or yield. If it wants
a lua error to be signaled, then it returns a `primer::error` containing the error message. The wrapped function
will translate the `primer::result` into corresponding lua C api calls.

The `PRIMER_ADAPT` macro is defined as `& adaptor< decltype(f), f>::adapted`.

[h2 Customization]

If you would like to implement a custom parameter reading / error handling mechanism, you can do that by introducing
a new return type for such functions, and specializing the `adaptor` class template for function pointers with your
given return type.

[endsect]
