[section Adapt]

`PRIMER_ADAPT` is the basic dispatch mechanism that implements type-safe parameter reading and error handling.

Given a function pointer e.g.

```
  primer::result my_func(lua_State * L, std::string s, int x, int y);
```

it can be pushed directly to lua using

```
  lua_pushcfunction(L, PRIMER_ADAPT(&my_func));
```

That is, the type of `PRIMER_ADAPT(&my_func)` is `lua_CFunction, i.e. int (*)(lua_State*)`.

  

The core object is a template

[primer_adaptor_decl]

which, given a function pointer `f`, is expected to provide a static member function of signature
`int (lua_State *)` which is named `adapted`.

For example:

[primer_adaptor_trivial]

When given a function pointer which returns `primer::result`, the adaptor wraps it in some boilerplate
which when invoked, attempts to read values off of the lua stack which match the function signature, using
`primer::read`.

In case this fails, it immediately reports an argument error to the lua code, with index and expected type.
If it succeeds, it passes the parsed arguments on to `f`.

The adaptor is wraps a given function pointer with some boilerplate which when invoked, will attempt to read
values off of the lua stack which match the function signature, using `primer::read`. In case this fails, it
immediately reports an error to lua code with the argument index and expected type. If it succeeds, it passes
the arguments to `f`.

The adapted function is supposed to push its return values onto the stack, if it plans to return or yield. If it wants
a lua error to be signaled, then it returns a `primer::error` containing the error message. The wrapped function
will translate the `primer::result` into corresponding lua C api calls.

The `PRIMER_ADAPT` macro is defined:
[primer_adapt]

[h2 `primer::result`]

`primer::result` is a structure that signals how to terminate a lua
function call.

There are three possible signals:

* return
* yield
* error

Return and yield both take an `int`, indicating how many return values went on the stack.

error is indicated by a `primer::error` object.

Code to send corresponding signal to lua is in
`<primer/detail/implement_result.hpp>`

[primer_result]

[h2 Customization]

If you would like to implement a custom parameter reading / error handling mechanism, you can do that by introducing
a new return type for such functions, and specializing the `adaptor` class template for function pointers with your
given return type.

Your functions using the new return type would then be automatically recognized also by `PRIMER_ADAPT_USERDATA`
and `USE_LUA_CALLBACK` in an `api::base` object.

[endsect]
