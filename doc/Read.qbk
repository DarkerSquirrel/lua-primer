[section read]

`primer::read` is a template function used to read a C++ value from the lua stack.

[primer_read]

* `read` returns a value of type `T`, or a human-readable error message explaining
  why the value on the stack could not be converted to `T`.
* `read` is not permitted to leave the stack in a different state than it was found.

You should always test the result of `primer::read` for safety, and not
assume that it will succeed in any given case. If the result is in an error state,
then applying `operator *` will result in undefined behavior.

[h3 Supported Types]

The following core types are supported:

[table
 [[Type] [`primer::read`]]
 [[ `bool` ]              [ Checks `lua_isboolean`, returns value of `lua_toboolean`. ]]
 [[ `int`]                [ Checks `lua_isinteger`, returns value of `lua_tointeger`. ]]
 [[ `long`]               []]
 [[ `long long`]          []]
 [[ `unsigned int` ]      [ Checks `lua_isinteger`, returns value of `lua_tointeger`. Fails if the value is negative. ]]
 [[ `unsigned long`]      []]
 [[ `unsigned long long`] []]
 [[ `float` ]             [ Checks `lua_isnumber`, returns value of `lua_tonumber`. ]]
 [[ `double`]             []]
 [[ `long double`]        []]
 [[ `const char *` ]      [ Checks `lua_isstring`, returns value of `lua_tostring`. ]]
 [[ `std::string`  ]      []]
]

In the above table, "Checks" means that, the checked function must report "true" or an error is reported.

[note In the above table, when an integral type is read, if the target type is *narrower* than `LUA_INTEGER`, then an overflow check is performed,
      and an overflow error will be reported if it occurs.

      To avoid the overhead of overflow checks, consider using the type `LUA_INTEGER` in your code, or only using `primer::read` with integral types known
      to be as large as `LUA_INTEGER`.

      Or, consider compiling lua using `-DLUA_32BITS` to force lua to
      use a 32 bit type for integers and floating point numbers internally.

      Alternatively, see "customization" below and specialize reading for `int`, `unsigned int`, etc. as you like. ]

[caution In the above table, when a floating point type is read, if the target type is *narrower* than `LUA_NUMBER`, no overflow check is performed,
      and the conversion is performed using a `static_cast`. This is because in many applications, the possibility of floating point overflow, underflow,
      or loss of precision is not a significant concern.

      If this is a major concern for you, consider specializing the `read` trait for `float`, `double`, etc., or using `LUA_NUMBER` in your code. ]

The following extra types are supported, which allow "flexible" reads.

This is useful for writing functions which allow in their parameters
certain implicit conversions typical of lua.

[primer_support_types]

[table
  [[Type] [`primer::read`]]
  [[ `primer::truthy`  ] [ Returns value of `lua_toboolean`. Does not fail. ]]
  [[ `primer::stringy` ] [ Returns value of `lua_tostring` if argument is string or number. Returns result of `__tostring` if metamethod is present and produces a string. Otherwise fails. ]]
  [[ `primer::nil_t`   ] [ Checks `lua_isnoneornil`. ]]
]

Primer includes additional headers to support some C++ standard containers and
and boost containers, which tables may be converted to. See the containers section for
details.

* `std::vector`
* `std::array`
* `std::set`
* `std::map`
* `std::unordered_map`
* `boost::flat_set`

[h3 Customization]

`primer::read`'s implementation is quite simple -- it delegates work to a ['type trait].
This trait, named `primer::traits::read`, can be specialized to override primer's behavior
for certain types, or to add new behavior for these custom types.

[primer_example_vec2i_defn]
[primer_example_vec2i_read_trait]
[primer_example_vec2i_read_test]

[endsect]
