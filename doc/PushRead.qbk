[section Push and Read]

`primer::read` and `primer::push` are template functions which provide the foundation of
primer. They are used to transfer C++ values to and from the lua stack. They have the following signatures:

``
  template <typename T>
  void push(lua_State * L, const T & t);

  template <typename T>
  expected<T> read(lua_State * L, int index);
``

`primer::push` cannot fail -- any C++ value that can be pushed, can be pushed without fail.

`primer::read` may fail. Commonly, it will fail if the value at that stack position cannot be interpreted
in the form of the requested type.

You should always test the result of `primer::read` for safety, and not
assume that it will succeed in any given case. In case of a failure, the object `expected<T>` will be in an
error state and will contain a human-readable explanation of the failure.

[h3 Side effects]

`primer::push` always should push exactly one object onto the stack.

`primer::read` always should leave the stack exactly as it found it. It should not
change the values or types of any object on the stack.

[h3 Customization]

`primer::read` and `primer::push` are each backed up by a ['trait], which may be specialized to add customized
behavior. You can see the primary template in `primer/traits/push.hpp` and `primer/traits/read.hpp`.
An example specialization looks like this:

```
  namespace primer {
  namespace traits {

  template <>
  struct read<my_type> {
    static expected<my_type> from_stack(lua_State * L, int index) {
      ...
    }
  };

  template <>
  struct push<my_type> {
    static void to_stack(lua_State * L, const my_type & t) {
      ...
    }
  };

  } // end namespace traits
  } // end namespace primer
```

Traits are used because it provides for more precise and powerful customization. For instance, if we merely used
function overloading, then all kinds of implicit conversions can come into play, and you also cannot provide partial
specializations.

[endsect]
