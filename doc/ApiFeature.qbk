[section API Feature]

An API feature is an object which is responsible to install some feature within
a lua State, and to provide support when we want to serialize / deserialize the
state.

```
  struct my_feature {
    void on_initialize(lua_State *);
    void on_persist_table(lua_State *);
    void on_unpersist_table(lua_State *);
  };
```

The `on_initialize` method is called when the API is initialized.

The `on_persist_table` method is called when we are persisting the state, and
need to construct the permanent objects table. When called, your feature will
get a state, and can assume that the permanent objects table is on top of the stack.
It should register each object, using the object as the key, and a serialization
name as the value.

The `on_unpersist_table` method is the same, but it does the reverse. The key
should be the serialization name, and the value should be the object.

Usually, permanent objects are just function pointers, but occasionally they
might be something else. For instance if there is a global userdata of some type,
it could be serialized by putting it in the permanent objects table, rather than
providing a `__persist` metamethod.

[h4 Extension]

Sometimes, the private state of an API feature is important, and you want
to have an easy way to serialize that state along with the rest of the lua
state. In this case you can provide the following two additional methods:

``
  void on_serialize(lua_State *);
  void on_deserialize(lua_State *);
``

These two methods hook into the persistence process in a different way --
instead of adjusting the permanent objects table, they add a value to the
['target] table.

When `on_serialize` is called,
the feature should push one lua value onto the stack which will be associated
to it and saved. It may be a complex table or any other thing that primer is
able to serialize. ['Exactly one value should be pushed.]

When `on_deserialize` is called, the feature may recover the lua value from the
stack, which it will find on top. It should use the value to restore its internal
state, [' then pop the value].

[h4 Behavior]
  
When `api::base::persist` is called, the permanent objects
table is constructed by calling `on_persist_table` for each API feature, and
the target table is constructed using `_G`, ['and each of the values provided by
an API feature which has an `on_serialize` method].

When `api::base::unpersist` is called, the reverse-permanent objects table
is constructed first using `on_unpersist_table`, and then the target table
is reconstructed from the given string. Then, each API feature with an
`on_deserialize` method is ['passed back the object which it pushed] onto the
stack, in order to restore its internal state. And the reproduced image of
`_G` replaces the current value of `_G`.


[h4 Declaration]

In order to actually hook into the methods of an `api::base` object, the feature
object needs to be a member variable of the `api::base`, and needs to be declared
using the `API_FEATURE` macro.

TODO EXAMPLE

[h4 Other]

To assert that a type declares the proper member functions to be an API feature,
you can use a `static_assert` like this:

``
  static_assert(primer::api::is_feature<T>::value, "T does not match the API_FEATURE concept!");
``

To assert that it further is a "serial feature" containing the `on_serialize`
and `on_deserialize` methods, you can use the `is_serial_feature trait`:

``
  static_assert(primer::api::is_serial_feature<T>::value, "T does not match the serial feature concept!");
``

If a type is recognized as a feature but not a serial feature, because it has only one of
`on_serialize` and `on_deserialize`, it will just be silently used as an API feature, so
for debugging purposes the above assertion is sometimes useful.


[endsect]
